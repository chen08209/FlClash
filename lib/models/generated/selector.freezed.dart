// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of '../selector.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$VM2<A, B> {
  A get a => throw _privateConstructorUsedError;
  B get b => throw _privateConstructorUsedError;

  /// Create a copy of VM2
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $VM2CopyWith<A, B, VM2<A, B>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VM2CopyWith<A, B, $Res> {
  factory $VM2CopyWith(VM2<A, B> value, $Res Function(VM2<A, B>) then) =
      _$VM2CopyWithImpl<A, B, $Res, VM2<A, B>>;
  @useResult
  $Res call({A a, B b});
}

/// @nodoc
class _$VM2CopyWithImpl<A, B, $Res, $Val extends VM2<A, B>>
    implements $VM2CopyWith<A, B, $Res> {
  _$VM2CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of VM2
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
    Object? b = freezed,
  }) {
    return _then(_value.copyWith(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as A,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as B,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VM2ImplCopyWith<A, B, $Res>
    implements $VM2CopyWith<A, B, $Res> {
  factory _$$VM2ImplCopyWith(
          _$VM2Impl<A, B> value, $Res Function(_$VM2Impl<A, B>) then) =
      __$$VM2ImplCopyWithImpl<A, B, $Res>;
  @override
  @useResult
  $Res call({A a, B b});
}

/// @nodoc
class __$$VM2ImplCopyWithImpl<A, B, $Res>
    extends _$VM2CopyWithImpl<A, B, $Res, _$VM2Impl<A, B>>
    implements _$$VM2ImplCopyWith<A, B, $Res> {
  __$$VM2ImplCopyWithImpl(
      _$VM2Impl<A, B> _value, $Res Function(_$VM2Impl<A, B>) _then)
      : super(_value, _then);

  /// Create a copy of VM2
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
    Object? b = freezed,
  }) {
    return _then(_$VM2Impl<A, B>(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as A,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as B,
    ));
  }
}

/// @nodoc

class _$VM2Impl<A, B> implements _VM2<A, B> {
  const _$VM2Impl({required this.a, required this.b});

  @override
  final A a;
  @override
  final B b;

  @override
  String toString() {
    return 'VM2<$A, $B>(a: $a, b: $b)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VM2Impl<A, B> &&
            const DeepCollectionEquality().equals(other.a, a) &&
            const DeepCollectionEquality().equals(other.b, b));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(a),
      const DeepCollectionEquality().hash(b));

  /// Create a copy of VM2
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$VM2ImplCopyWith<A, B, _$VM2Impl<A, B>> get copyWith =>
      __$$VM2ImplCopyWithImpl<A, B, _$VM2Impl<A, B>>(this, _$identity);
}

abstract class _VM2<A, B> implements VM2<A, B> {
  const factory _VM2({required final A a, required final B b}) =
      _$VM2Impl<A, B>;

  @override
  A get a;
  @override
  B get b;

  /// Create a copy of VM2
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$VM2ImplCopyWith<A, B, _$VM2Impl<A, B>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$VM3<A, B, C> {
  A get a => throw _privateConstructorUsedError;
  B get b => throw _privateConstructorUsedError;
  C get c => throw _privateConstructorUsedError;

  /// Create a copy of VM3
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $VM3CopyWith<A, B, C, VM3<A, B, C>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VM3CopyWith<A, B, C, $Res> {
  factory $VM3CopyWith(VM3<A, B, C> value, $Res Function(VM3<A, B, C>) then) =
      _$VM3CopyWithImpl<A, B, C, $Res, VM3<A, B, C>>;
  @useResult
  $Res call({A a, B b, C c});
}

/// @nodoc
class _$VM3CopyWithImpl<A, B, C, $Res, $Val extends VM3<A, B, C>>
    implements $VM3CopyWith<A, B, C, $Res> {
  _$VM3CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of VM3
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
    Object? b = freezed,
    Object? c = freezed,
  }) {
    return _then(_value.copyWith(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as A,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as B,
      c: freezed == c
          ? _value.c
          : c // ignore: cast_nullable_to_non_nullable
              as C,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VM3ImplCopyWith<A, B, C, $Res>
    implements $VM3CopyWith<A, B, C, $Res> {
  factory _$$VM3ImplCopyWith(
          _$VM3Impl<A, B, C> value, $Res Function(_$VM3Impl<A, B, C>) then) =
      __$$VM3ImplCopyWithImpl<A, B, C, $Res>;
  @override
  @useResult
  $Res call({A a, B b, C c});
}

/// @nodoc
class __$$VM3ImplCopyWithImpl<A, B, C, $Res>
    extends _$VM3CopyWithImpl<A, B, C, $Res, _$VM3Impl<A, B, C>>
    implements _$$VM3ImplCopyWith<A, B, C, $Res> {
  __$$VM3ImplCopyWithImpl(
      _$VM3Impl<A, B, C> _value, $Res Function(_$VM3Impl<A, B, C>) _then)
      : super(_value, _then);

  /// Create a copy of VM3
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
    Object? b = freezed,
    Object? c = freezed,
  }) {
    return _then(_$VM3Impl<A, B, C>(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as A,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as B,
      c: freezed == c
          ? _value.c
          : c // ignore: cast_nullable_to_non_nullable
              as C,
    ));
  }
}

/// @nodoc

class _$VM3Impl<A, B, C> implements _VM3<A, B, C> {
  const _$VM3Impl({required this.a, required this.b, required this.c});

  @override
  final A a;
  @override
  final B b;
  @override
  final C c;

  @override
  String toString() {
    return 'VM3<$A, $B, $C>(a: $a, b: $b, c: $c)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VM3Impl<A, B, C> &&
            const DeepCollectionEquality().equals(other.a, a) &&
            const DeepCollectionEquality().equals(other.b, b) &&
            const DeepCollectionEquality().equals(other.c, c));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(a),
      const DeepCollectionEquality().hash(b),
      const DeepCollectionEquality().hash(c));

  /// Create a copy of VM3
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$VM3ImplCopyWith<A, B, C, _$VM3Impl<A, B, C>> get copyWith =>
      __$$VM3ImplCopyWithImpl<A, B, C, _$VM3Impl<A, B, C>>(this, _$identity);
}

abstract class _VM3<A, B, C> implements VM3<A, B, C> {
  const factory _VM3(
      {required final A a,
      required final B b,
      required final C c}) = _$VM3Impl<A, B, C>;

  @override
  A get a;
  @override
  B get b;
  @override
  C get c;

  /// Create a copy of VM3
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$VM3ImplCopyWith<A, B, C, _$VM3Impl<A, B, C>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$VM4<A, B, C, D> {
  A get a => throw _privateConstructorUsedError;
  B get b => throw _privateConstructorUsedError;
  C get c => throw _privateConstructorUsedError;
  D get d => throw _privateConstructorUsedError;

  /// Create a copy of VM4
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $VM4CopyWith<A, B, C, D, VM4<A, B, C, D>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VM4CopyWith<A, B, C, D, $Res> {
  factory $VM4CopyWith(
          VM4<A, B, C, D> value, $Res Function(VM4<A, B, C, D>) then) =
      _$VM4CopyWithImpl<A, B, C, D, $Res, VM4<A, B, C, D>>;
  @useResult
  $Res call({A a, B b, C c, D d});
}

/// @nodoc
class _$VM4CopyWithImpl<A, B, C, D, $Res, $Val extends VM4<A, B, C, D>>
    implements $VM4CopyWith<A, B, C, D, $Res> {
  _$VM4CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of VM4
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
    Object? b = freezed,
    Object? c = freezed,
    Object? d = freezed,
  }) {
    return _then(_value.copyWith(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as A,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as B,
      c: freezed == c
          ? _value.c
          : c // ignore: cast_nullable_to_non_nullable
              as C,
      d: freezed == d
          ? _value.d
          : d // ignore: cast_nullable_to_non_nullable
              as D,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VM4ImplCopyWith<A, B, C, D, $Res>
    implements $VM4CopyWith<A, B, C, D, $Res> {
  factory _$$VM4ImplCopyWith(_$VM4Impl<A, B, C, D> value,
          $Res Function(_$VM4Impl<A, B, C, D>) then) =
      __$$VM4ImplCopyWithImpl<A, B, C, D, $Res>;
  @override
  @useResult
  $Res call({A a, B b, C c, D d});
}

/// @nodoc
class __$$VM4ImplCopyWithImpl<A, B, C, D, $Res>
    extends _$VM4CopyWithImpl<A, B, C, D, $Res, _$VM4Impl<A, B, C, D>>
    implements _$$VM4ImplCopyWith<A, B, C, D, $Res> {
  __$$VM4ImplCopyWithImpl(
      _$VM4Impl<A, B, C, D> _value, $Res Function(_$VM4Impl<A, B, C, D>) _then)
      : super(_value, _then);

  /// Create a copy of VM4
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
    Object? b = freezed,
    Object? c = freezed,
    Object? d = freezed,
  }) {
    return _then(_$VM4Impl<A, B, C, D>(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as A,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as B,
      c: freezed == c
          ? _value.c
          : c // ignore: cast_nullable_to_non_nullable
              as C,
      d: freezed == d
          ? _value.d
          : d // ignore: cast_nullable_to_non_nullable
              as D,
    ));
  }
}

/// @nodoc

class _$VM4Impl<A, B, C, D> implements _VM4<A, B, C, D> {
  const _$VM4Impl(
      {required this.a, required this.b, required this.c, required this.d});

  @override
  final A a;
  @override
  final B b;
  @override
  final C c;
  @override
  final D d;

  @override
  String toString() {
    return 'VM4<$A, $B, $C, $D>(a: $a, b: $b, c: $c, d: $d)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VM4Impl<A, B, C, D> &&
            const DeepCollectionEquality().equals(other.a, a) &&
            const DeepCollectionEquality().equals(other.b, b) &&
            const DeepCollectionEquality().equals(other.c, c) &&
            const DeepCollectionEquality().equals(other.d, d));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(a),
      const DeepCollectionEquality().hash(b),
      const DeepCollectionEquality().hash(c),
      const DeepCollectionEquality().hash(d));

  /// Create a copy of VM4
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$VM4ImplCopyWith<A, B, C, D, _$VM4Impl<A, B, C, D>> get copyWith =>
      __$$VM4ImplCopyWithImpl<A, B, C, D, _$VM4Impl<A, B, C, D>>(
          this, _$identity);
}

abstract class _VM4<A, B, C, D> implements VM4<A, B, C, D> {
  const factory _VM4(
      {required final A a,
      required final B b,
      required final C c,
      required final D d}) = _$VM4Impl<A, B, C, D>;

  @override
  A get a;
  @override
  B get b;
  @override
  C get c;
  @override
  D get d;

  /// Create a copy of VM4
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$VM4ImplCopyWith<A, B, C, D, _$VM4Impl<A, B, C, D>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$VM5<A, B, C, D, E> {
  A get a => throw _privateConstructorUsedError;
  B get b => throw _privateConstructorUsedError;
  C get c => throw _privateConstructorUsedError;
  D get d => throw _privateConstructorUsedError;
  E get e => throw _privateConstructorUsedError;

  /// Create a copy of VM5
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $VM5CopyWith<A, B, C, D, E, VM5<A, B, C, D, E>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VM5CopyWith<A, B, C, D, E, $Res> {
  factory $VM5CopyWith(
          VM5<A, B, C, D, E> value, $Res Function(VM5<A, B, C, D, E>) then) =
      _$VM5CopyWithImpl<A, B, C, D, E, $Res, VM5<A, B, C, D, E>>;
  @useResult
  $Res call({A a, B b, C c, D d, E e});
}

/// @nodoc
class _$VM5CopyWithImpl<A, B, C, D, E, $Res, $Val extends VM5<A, B, C, D, E>>
    implements $VM5CopyWith<A, B, C, D, E, $Res> {
  _$VM5CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of VM5
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
    Object? b = freezed,
    Object? c = freezed,
    Object? d = freezed,
    Object? e = freezed,
  }) {
    return _then(_value.copyWith(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as A,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as B,
      c: freezed == c
          ? _value.c
          : c // ignore: cast_nullable_to_non_nullable
              as C,
      d: freezed == d
          ? _value.d
          : d // ignore: cast_nullable_to_non_nullable
              as D,
      e: freezed == e
          ? _value.e
          : e // ignore: cast_nullable_to_non_nullable
              as E,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VM5ImplCopyWith<A, B, C, D, E, $Res>
    implements $VM5CopyWith<A, B, C, D, E, $Res> {
  factory _$$VM5ImplCopyWith(_$VM5Impl<A, B, C, D, E> value,
          $Res Function(_$VM5Impl<A, B, C, D, E>) then) =
      __$$VM5ImplCopyWithImpl<A, B, C, D, E, $Res>;
  @override
  @useResult
  $Res call({A a, B b, C c, D d, E e});
}

/// @nodoc
class __$$VM5ImplCopyWithImpl<A, B, C, D, E, $Res>
    extends _$VM5CopyWithImpl<A, B, C, D, E, $Res, _$VM5Impl<A, B, C, D, E>>
    implements _$$VM5ImplCopyWith<A, B, C, D, E, $Res> {
  __$$VM5ImplCopyWithImpl(_$VM5Impl<A, B, C, D, E> _value,
      $Res Function(_$VM5Impl<A, B, C, D, E>) _then)
      : super(_value, _then);

  /// Create a copy of VM5
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
    Object? b = freezed,
    Object? c = freezed,
    Object? d = freezed,
    Object? e = freezed,
  }) {
    return _then(_$VM5Impl<A, B, C, D, E>(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as A,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as B,
      c: freezed == c
          ? _value.c
          : c // ignore: cast_nullable_to_non_nullable
              as C,
      d: freezed == d
          ? _value.d
          : d // ignore: cast_nullable_to_non_nullable
              as D,
      e: freezed == e
          ? _value.e
          : e // ignore: cast_nullable_to_non_nullable
              as E,
    ));
  }
}

/// @nodoc

class _$VM5Impl<A, B, C, D, E> implements _VM5<A, B, C, D, E> {
  const _$VM5Impl(
      {required this.a,
      required this.b,
      required this.c,
      required this.d,
      required this.e});

  @override
  final A a;
  @override
  final B b;
  @override
  final C c;
  @override
  final D d;
  @override
  final E e;

  @override
  String toString() {
    return 'VM5<$A, $B, $C, $D, $E>(a: $a, b: $b, c: $c, d: $d, e: $e)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VM5Impl<A, B, C, D, E> &&
            const DeepCollectionEquality().equals(other.a, a) &&
            const DeepCollectionEquality().equals(other.b, b) &&
            const DeepCollectionEquality().equals(other.c, c) &&
            const DeepCollectionEquality().equals(other.d, d) &&
            const DeepCollectionEquality().equals(other.e, e));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(a),
      const DeepCollectionEquality().hash(b),
      const DeepCollectionEquality().hash(c),
      const DeepCollectionEquality().hash(d),
      const DeepCollectionEquality().hash(e));

  /// Create a copy of VM5
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$VM5ImplCopyWith<A, B, C, D, E, _$VM5Impl<A, B, C, D, E>> get copyWith =>
      __$$VM5ImplCopyWithImpl<A, B, C, D, E, _$VM5Impl<A, B, C, D, E>>(
          this, _$identity);
}

abstract class _VM5<A, B, C, D, E> implements VM5<A, B, C, D, E> {
  const factory _VM5(
      {required final A a,
      required final B b,
      required final C c,
      required final D d,
      required final E e}) = _$VM5Impl<A, B, C, D, E>;

  @override
  A get a;
  @override
  B get b;
  @override
  C get c;
  @override
  D get d;
  @override
  E get e;

  /// Create a copy of VM5
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$VM5ImplCopyWith<A, B, C, D, E, _$VM5Impl<A, B, C, D, E>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StartButtonSelectorState {
  bool get isInit => throw _privateConstructorUsedError;
  bool get hasProfile => throw _privateConstructorUsedError;

  /// Create a copy of StartButtonSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StartButtonSelectorStateCopyWith<StartButtonSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StartButtonSelectorStateCopyWith<$Res> {
  factory $StartButtonSelectorStateCopyWith(StartButtonSelectorState value,
          $Res Function(StartButtonSelectorState) then) =
      _$StartButtonSelectorStateCopyWithImpl<$Res, StartButtonSelectorState>;
  @useResult
  $Res call({bool isInit, bool hasProfile});
}

/// @nodoc
class _$StartButtonSelectorStateCopyWithImpl<$Res,
        $Val extends StartButtonSelectorState>
    implements $StartButtonSelectorStateCopyWith<$Res> {
  _$StartButtonSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StartButtonSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isInit = null,
    Object? hasProfile = null,
  }) {
    return _then(_value.copyWith(
      isInit: null == isInit
          ? _value.isInit
          : isInit // ignore: cast_nullable_to_non_nullable
              as bool,
      hasProfile: null == hasProfile
          ? _value.hasProfile
          : hasProfile // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StartButtonSelectorStateImplCopyWith<$Res>
    implements $StartButtonSelectorStateCopyWith<$Res> {
  factory _$$StartButtonSelectorStateImplCopyWith(
          _$StartButtonSelectorStateImpl value,
          $Res Function(_$StartButtonSelectorStateImpl) then) =
      __$$StartButtonSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isInit, bool hasProfile});
}

/// @nodoc
class __$$StartButtonSelectorStateImplCopyWithImpl<$Res>
    extends _$StartButtonSelectorStateCopyWithImpl<$Res,
        _$StartButtonSelectorStateImpl>
    implements _$$StartButtonSelectorStateImplCopyWith<$Res> {
  __$$StartButtonSelectorStateImplCopyWithImpl(
      _$StartButtonSelectorStateImpl _value,
      $Res Function(_$StartButtonSelectorStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of StartButtonSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isInit = null,
    Object? hasProfile = null,
  }) {
    return _then(_$StartButtonSelectorStateImpl(
      isInit: null == isInit
          ? _value.isInit
          : isInit // ignore: cast_nullable_to_non_nullable
              as bool,
      hasProfile: null == hasProfile
          ? _value.hasProfile
          : hasProfile // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$StartButtonSelectorStateImpl implements _StartButtonSelectorState {
  const _$StartButtonSelectorStateImpl(
      {required this.isInit, required this.hasProfile});

  @override
  final bool isInit;
  @override
  final bool hasProfile;

  @override
  String toString() {
    return 'StartButtonSelectorState(isInit: $isInit, hasProfile: $hasProfile)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StartButtonSelectorStateImpl &&
            (identical(other.isInit, isInit) || other.isInit == isInit) &&
            (identical(other.hasProfile, hasProfile) ||
                other.hasProfile == hasProfile));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isInit, hasProfile);

  /// Create a copy of StartButtonSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StartButtonSelectorStateImplCopyWith<_$StartButtonSelectorStateImpl>
      get copyWith => __$$StartButtonSelectorStateImplCopyWithImpl<
          _$StartButtonSelectorStateImpl>(this, _$identity);
}

abstract class _StartButtonSelectorState implements StartButtonSelectorState {
  const factory _StartButtonSelectorState(
      {required final bool isInit,
      required final bool hasProfile}) = _$StartButtonSelectorStateImpl;

  @override
  bool get isInit;
  @override
  bool get hasProfile;

  /// Create a copy of StartButtonSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StartButtonSelectorStateImplCopyWith<_$StartButtonSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProfilesSelectorState {
  List<Profile> get profiles => throw _privateConstructorUsedError;
  String? get currentProfileId => throw _privateConstructorUsedError;
  int get columns => throw _privateConstructorUsedError;

  /// Create a copy of ProfilesSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProfilesSelectorStateCopyWith<ProfilesSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProfilesSelectorStateCopyWith<$Res> {
  factory $ProfilesSelectorStateCopyWith(ProfilesSelectorState value,
          $Res Function(ProfilesSelectorState) then) =
      _$ProfilesSelectorStateCopyWithImpl<$Res, ProfilesSelectorState>;
  @useResult
  $Res call({List<Profile> profiles, String? currentProfileId, int columns});
}

/// @nodoc
class _$ProfilesSelectorStateCopyWithImpl<$Res,
        $Val extends ProfilesSelectorState>
    implements $ProfilesSelectorStateCopyWith<$Res> {
  _$ProfilesSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProfilesSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? profiles = null,
    Object? currentProfileId = freezed,
    Object? columns = null,
  }) {
    return _then(_value.copyWith(
      profiles: null == profiles
          ? _value.profiles
          : profiles // ignore: cast_nullable_to_non_nullable
              as List<Profile>,
      currentProfileId: freezed == currentProfileId
          ? _value.currentProfileId
          : currentProfileId // ignore: cast_nullable_to_non_nullable
              as String?,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProfilesSelectorStateImplCopyWith<$Res>
    implements $ProfilesSelectorStateCopyWith<$Res> {
  factory _$$ProfilesSelectorStateImplCopyWith(
          _$ProfilesSelectorStateImpl value,
          $Res Function(_$ProfilesSelectorStateImpl) then) =
      __$$ProfilesSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<Profile> profiles, String? currentProfileId, int columns});
}

/// @nodoc
class __$$ProfilesSelectorStateImplCopyWithImpl<$Res>
    extends _$ProfilesSelectorStateCopyWithImpl<$Res,
        _$ProfilesSelectorStateImpl>
    implements _$$ProfilesSelectorStateImplCopyWith<$Res> {
  __$$ProfilesSelectorStateImplCopyWithImpl(_$ProfilesSelectorStateImpl _value,
      $Res Function(_$ProfilesSelectorStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProfilesSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? profiles = null,
    Object? currentProfileId = freezed,
    Object? columns = null,
  }) {
    return _then(_$ProfilesSelectorStateImpl(
      profiles: null == profiles
          ? _value._profiles
          : profiles // ignore: cast_nullable_to_non_nullable
              as List<Profile>,
      currentProfileId: freezed == currentProfileId
          ? _value.currentProfileId
          : currentProfileId // ignore: cast_nullable_to_non_nullable
              as String?,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ProfilesSelectorStateImpl implements _ProfilesSelectorState {
  const _$ProfilesSelectorStateImpl(
      {required final List<Profile> profiles,
      required this.currentProfileId,
      required this.columns})
      : _profiles = profiles;

  final List<Profile> _profiles;
  @override
  List<Profile> get profiles {
    if (_profiles is EqualUnmodifiableListView) return _profiles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_profiles);
  }

  @override
  final String? currentProfileId;
  @override
  final int columns;

  @override
  String toString() {
    return 'ProfilesSelectorState(profiles: $profiles, currentProfileId: $currentProfileId, columns: $columns)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProfilesSelectorStateImpl &&
            const DeepCollectionEquality().equals(other._profiles, _profiles) &&
            (identical(other.currentProfileId, currentProfileId) ||
                other.currentProfileId == currentProfileId) &&
            (identical(other.columns, columns) || other.columns == columns));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_profiles),
      currentProfileId,
      columns);

  /// Create a copy of ProfilesSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProfilesSelectorStateImplCopyWith<_$ProfilesSelectorStateImpl>
      get copyWith => __$$ProfilesSelectorStateImplCopyWithImpl<
          _$ProfilesSelectorStateImpl>(this, _$identity);
}

abstract class _ProfilesSelectorState implements ProfilesSelectorState {
  const factory _ProfilesSelectorState(
      {required final List<Profile> profiles,
      required final String? currentProfileId,
      required final int columns}) = _$ProfilesSelectorStateImpl;

  @override
  List<Profile> get profiles;
  @override
  String? get currentProfileId;
  @override
  int get columns;

  /// Create a copy of ProfilesSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProfilesSelectorStateImplCopyWith<_$ProfilesSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NetworkDetectionState {
  bool get isLoading => throw _privateConstructorUsedError;
  IpInfo? get ipInfo => throw _privateConstructorUsedError;

  /// Create a copy of NetworkDetectionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NetworkDetectionStateCopyWith<NetworkDetectionState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NetworkDetectionStateCopyWith<$Res> {
  factory $NetworkDetectionStateCopyWith(NetworkDetectionState value,
          $Res Function(NetworkDetectionState) then) =
      _$NetworkDetectionStateCopyWithImpl<$Res, NetworkDetectionState>;
  @useResult
  $Res call({bool isLoading, IpInfo? ipInfo});
}

/// @nodoc
class _$NetworkDetectionStateCopyWithImpl<$Res,
        $Val extends NetworkDetectionState>
    implements $NetworkDetectionStateCopyWith<$Res> {
  _$NetworkDetectionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NetworkDetectionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? ipInfo = freezed,
  }) {
    return _then(_value.copyWith(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      ipInfo: freezed == ipInfo
          ? _value.ipInfo
          : ipInfo // ignore: cast_nullable_to_non_nullable
              as IpInfo?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NetworkDetectionStateImplCopyWith<$Res>
    implements $NetworkDetectionStateCopyWith<$Res> {
  factory _$$NetworkDetectionStateImplCopyWith(
          _$NetworkDetectionStateImpl value,
          $Res Function(_$NetworkDetectionStateImpl) then) =
      __$$NetworkDetectionStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isLoading, IpInfo? ipInfo});
}

/// @nodoc
class __$$NetworkDetectionStateImplCopyWithImpl<$Res>
    extends _$NetworkDetectionStateCopyWithImpl<$Res,
        _$NetworkDetectionStateImpl>
    implements _$$NetworkDetectionStateImplCopyWith<$Res> {
  __$$NetworkDetectionStateImplCopyWithImpl(_$NetworkDetectionStateImpl _value,
      $Res Function(_$NetworkDetectionStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of NetworkDetectionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? ipInfo = freezed,
  }) {
    return _then(_$NetworkDetectionStateImpl(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      ipInfo: freezed == ipInfo
          ? _value.ipInfo
          : ipInfo // ignore: cast_nullable_to_non_nullable
              as IpInfo?,
    ));
  }
}

/// @nodoc

class _$NetworkDetectionStateImpl implements _NetworkDetectionState {
  const _$NetworkDetectionStateImpl(
      {required this.isLoading, required this.ipInfo});

  @override
  final bool isLoading;
  @override
  final IpInfo? ipInfo;

  @override
  String toString() {
    return 'NetworkDetectionState(isLoading: $isLoading, ipInfo: $ipInfo)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NetworkDetectionStateImpl &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.ipInfo, ipInfo) || other.ipInfo == ipInfo));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isLoading, ipInfo);

  /// Create a copy of NetworkDetectionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NetworkDetectionStateImplCopyWith<_$NetworkDetectionStateImpl>
      get copyWith => __$$NetworkDetectionStateImplCopyWithImpl<
          _$NetworkDetectionStateImpl>(this, _$identity);
}

abstract class _NetworkDetectionState implements NetworkDetectionState {
  const factory _NetworkDetectionState(
      {required final bool isLoading,
      required final IpInfo? ipInfo}) = _$NetworkDetectionStateImpl;

  @override
  bool get isLoading;
  @override
  IpInfo? get ipInfo;

  /// Create a copy of NetworkDetectionState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NetworkDetectionStateImplCopyWith<_$NetworkDetectionStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TrayState {
  Mode get mode => throw _privateConstructorUsedError;
  int get port => throw _privateConstructorUsedError;
  bool get autoLaunch => throw _privateConstructorUsedError;
  bool get systemProxy => throw _privateConstructorUsedError;
  bool get tunEnable => throw _privateConstructorUsedError;
  bool get isStart => throw _privateConstructorUsedError;
  String? get locale => throw _privateConstructorUsedError;
  Brightness? get brightness => throw _privateConstructorUsedError;
  List<Group> get groups => throw _privateConstructorUsedError;
  Map<String, String> get selectedMap => throw _privateConstructorUsedError;

  /// Create a copy of TrayState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TrayStateCopyWith<TrayState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TrayStateCopyWith<$Res> {
  factory $TrayStateCopyWith(TrayState value, $Res Function(TrayState) then) =
      _$TrayStateCopyWithImpl<$Res, TrayState>;
  @useResult
  $Res call(
      {Mode mode,
      int port,
      bool autoLaunch,
      bool systemProxy,
      bool tunEnable,
      bool isStart,
      String? locale,
      Brightness? brightness,
      List<Group> groups,
      Map<String, String> selectedMap});
}

/// @nodoc
class _$TrayStateCopyWithImpl<$Res, $Val extends TrayState>
    implements $TrayStateCopyWith<$Res> {
  _$TrayStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TrayState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = null,
    Object? port = null,
    Object? autoLaunch = null,
    Object? systemProxy = null,
    Object? tunEnable = null,
    Object? isStart = null,
    Object? locale = freezed,
    Object? brightness = freezed,
    Object? groups = null,
    Object? selectedMap = null,
  }) {
    return _then(_value.copyWith(
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as Mode,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
      autoLaunch: null == autoLaunch
          ? _value.autoLaunch
          : autoLaunch // ignore: cast_nullable_to_non_nullable
              as bool,
      systemProxy: null == systemProxy
          ? _value.systemProxy
          : systemProxy // ignore: cast_nullable_to_non_nullable
              as bool,
      tunEnable: null == tunEnable
          ? _value.tunEnable
          : tunEnable // ignore: cast_nullable_to_non_nullable
              as bool,
      isStart: null == isStart
          ? _value.isStart
          : isStart // ignore: cast_nullable_to_non_nullable
              as bool,
      locale: freezed == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
      brightness: freezed == brightness
          ? _value.brightness
          : brightness // ignore: cast_nullable_to_non_nullable
              as Brightness?,
      groups: null == groups
          ? _value.groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Group>,
      selectedMap: null == selectedMap
          ? _value.selectedMap
          : selectedMap // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TrayStateImplCopyWith<$Res>
    implements $TrayStateCopyWith<$Res> {
  factory _$$TrayStateImplCopyWith(
          _$TrayStateImpl value, $Res Function(_$TrayStateImpl) then) =
      __$$TrayStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Mode mode,
      int port,
      bool autoLaunch,
      bool systemProxy,
      bool tunEnable,
      bool isStart,
      String? locale,
      Brightness? brightness,
      List<Group> groups,
      Map<String, String> selectedMap});
}

/// @nodoc
class __$$TrayStateImplCopyWithImpl<$Res>
    extends _$TrayStateCopyWithImpl<$Res, _$TrayStateImpl>
    implements _$$TrayStateImplCopyWith<$Res> {
  __$$TrayStateImplCopyWithImpl(
      _$TrayStateImpl _value, $Res Function(_$TrayStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of TrayState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = null,
    Object? port = null,
    Object? autoLaunch = null,
    Object? systemProxy = null,
    Object? tunEnable = null,
    Object? isStart = null,
    Object? locale = freezed,
    Object? brightness = freezed,
    Object? groups = null,
    Object? selectedMap = null,
  }) {
    return _then(_$TrayStateImpl(
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as Mode,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
      autoLaunch: null == autoLaunch
          ? _value.autoLaunch
          : autoLaunch // ignore: cast_nullable_to_non_nullable
              as bool,
      systemProxy: null == systemProxy
          ? _value.systemProxy
          : systemProxy // ignore: cast_nullable_to_non_nullable
              as bool,
      tunEnable: null == tunEnable
          ? _value.tunEnable
          : tunEnable // ignore: cast_nullable_to_non_nullable
              as bool,
      isStart: null == isStart
          ? _value.isStart
          : isStart // ignore: cast_nullable_to_non_nullable
              as bool,
      locale: freezed == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
      brightness: freezed == brightness
          ? _value.brightness
          : brightness // ignore: cast_nullable_to_non_nullable
              as Brightness?,
      groups: null == groups
          ? _value._groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Group>,
      selectedMap: null == selectedMap
          ? _value._selectedMap
          : selectedMap // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ));
  }
}

/// @nodoc

class _$TrayStateImpl implements _TrayState {
  const _$TrayStateImpl(
      {required this.mode,
      required this.port,
      required this.autoLaunch,
      required this.systemProxy,
      required this.tunEnable,
      required this.isStart,
      required this.locale,
      required this.brightness,
      required final List<Group> groups,
      required final Map<String, String> selectedMap})
      : _groups = groups,
        _selectedMap = selectedMap;

  @override
  final Mode mode;
  @override
  final int port;
  @override
  final bool autoLaunch;
  @override
  final bool systemProxy;
  @override
  final bool tunEnable;
  @override
  final bool isStart;
  @override
  final String? locale;
  @override
  final Brightness? brightness;
  final List<Group> _groups;
  @override
  List<Group> get groups {
    if (_groups is EqualUnmodifiableListView) return _groups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_groups);
  }

  final Map<String, String> _selectedMap;
  @override
  Map<String, String> get selectedMap {
    if (_selectedMap is EqualUnmodifiableMapView) return _selectedMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_selectedMap);
  }

  @override
  String toString() {
    return 'TrayState(mode: $mode, port: $port, autoLaunch: $autoLaunch, systemProxy: $systemProxy, tunEnable: $tunEnable, isStart: $isStart, locale: $locale, brightness: $brightness, groups: $groups, selectedMap: $selectedMap)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TrayStateImpl &&
            (identical(other.mode, mode) || other.mode == mode) &&
            (identical(other.port, port) || other.port == port) &&
            (identical(other.autoLaunch, autoLaunch) ||
                other.autoLaunch == autoLaunch) &&
            (identical(other.systemProxy, systemProxy) ||
                other.systemProxy == systemProxy) &&
            (identical(other.tunEnable, tunEnable) ||
                other.tunEnable == tunEnable) &&
            (identical(other.isStart, isStart) || other.isStart == isStart) &&
            (identical(other.locale, locale) || other.locale == locale) &&
            (identical(other.brightness, brightness) ||
                other.brightness == brightness) &&
            const DeepCollectionEquality().equals(other._groups, _groups) &&
            const DeepCollectionEquality()
                .equals(other._selectedMap, _selectedMap));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      mode,
      port,
      autoLaunch,
      systemProxy,
      tunEnable,
      isStart,
      locale,
      brightness,
      const DeepCollectionEquality().hash(_groups),
      const DeepCollectionEquality().hash(_selectedMap));

  /// Create a copy of TrayState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TrayStateImplCopyWith<_$TrayStateImpl> get copyWith =>
      __$$TrayStateImplCopyWithImpl<_$TrayStateImpl>(this, _$identity);
}

abstract class _TrayState implements TrayState {
  const factory _TrayState(
      {required final Mode mode,
      required final int port,
      required final bool autoLaunch,
      required final bool systemProxy,
      required final bool tunEnable,
      required final bool isStart,
      required final String? locale,
      required final Brightness? brightness,
      required final List<Group> groups,
      required final Map<String, String> selectedMap}) = _$TrayStateImpl;

  @override
  Mode get mode;
  @override
  int get port;
  @override
  bool get autoLaunch;
  @override
  bool get systemProxy;
  @override
  bool get tunEnable;
  @override
  bool get isStart;
  @override
  String? get locale;
  @override
  Brightness? get brightness;
  @override
  List<Group> get groups;
  @override
  Map<String, String> get selectedMap;

  /// Create a copy of TrayState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TrayStateImplCopyWith<_$TrayStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NavigationState {
  PageLabel get pageLabel => throw _privateConstructorUsedError;
  List<NavigationItem> get navigationItems =>
      throw _privateConstructorUsedError;
  ViewMode get viewMode => throw _privateConstructorUsedError;
  String? get locale => throw _privateConstructorUsedError;
  int get currentIndex => throw _privateConstructorUsedError;

  /// Create a copy of NavigationState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NavigationStateCopyWith<NavigationState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NavigationStateCopyWith<$Res> {
  factory $NavigationStateCopyWith(
          NavigationState value, $Res Function(NavigationState) then) =
      _$NavigationStateCopyWithImpl<$Res, NavigationState>;
  @useResult
  $Res call(
      {PageLabel pageLabel,
      List<NavigationItem> navigationItems,
      ViewMode viewMode,
      String? locale,
      int currentIndex});
}

/// @nodoc
class _$NavigationStateCopyWithImpl<$Res, $Val extends NavigationState>
    implements $NavigationStateCopyWith<$Res> {
  _$NavigationStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NavigationState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageLabel = null,
    Object? navigationItems = null,
    Object? viewMode = null,
    Object? locale = freezed,
    Object? currentIndex = null,
  }) {
    return _then(_value.copyWith(
      pageLabel: null == pageLabel
          ? _value.pageLabel
          : pageLabel // ignore: cast_nullable_to_non_nullable
              as PageLabel,
      navigationItems: null == navigationItems
          ? _value.navigationItems
          : navigationItems // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
      viewMode: null == viewMode
          ? _value.viewMode
          : viewMode // ignore: cast_nullable_to_non_nullable
              as ViewMode,
      locale: freezed == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
      currentIndex: null == currentIndex
          ? _value.currentIndex
          : currentIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NavigationStateImplCopyWith<$Res>
    implements $NavigationStateCopyWith<$Res> {
  factory _$$NavigationStateImplCopyWith(_$NavigationStateImpl value,
          $Res Function(_$NavigationStateImpl) then) =
      __$$NavigationStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {PageLabel pageLabel,
      List<NavigationItem> navigationItems,
      ViewMode viewMode,
      String? locale,
      int currentIndex});
}

/// @nodoc
class __$$NavigationStateImplCopyWithImpl<$Res>
    extends _$NavigationStateCopyWithImpl<$Res, _$NavigationStateImpl>
    implements _$$NavigationStateImplCopyWith<$Res> {
  __$$NavigationStateImplCopyWithImpl(
      _$NavigationStateImpl _value, $Res Function(_$NavigationStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of NavigationState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageLabel = null,
    Object? navigationItems = null,
    Object? viewMode = null,
    Object? locale = freezed,
    Object? currentIndex = null,
  }) {
    return _then(_$NavigationStateImpl(
      pageLabel: null == pageLabel
          ? _value.pageLabel
          : pageLabel // ignore: cast_nullable_to_non_nullable
              as PageLabel,
      navigationItems: null == navigationItems
          ? _value._navigationItems
          : navigationItems // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
      viewMode: null == viewMode
          ? _value.viewMode
          : viewMode // ignore: cast_nullable_to_non_nullable
              as ViewMode,
      locale: freezed == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
      currentIndex: null == currentIndex
          ? _value.currentIndex
          : currentIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$NavigationStateImpl implements _NavigationState {
  const _$NavigationStateImpl(
      {required this.pageLabel,
      required final List<NavigationItem> navigationItems,
      required this.viewMode,
      required this.locale,
      required this.currentIndex})
      : _navigationItems = navigationItems;

  @override
  final PageLabel pageLabel;
  final List<NavigationItem> _navigationItems;
  @override
  List<NavigationItem> get navigationItems {
    if (_navigationItems is EqualUnmodifiableListView) return _navigationItems;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_navigationItems);
  }

  @override
  final ViewMode viewMode;
  @override
  final String? locale;
  @override
  final int currentIndex;

  @override
  String toString() {
    return 'NavigationState(pageLabel: $pageLabel, navigationItems: $navigationItems, viewMode: $viewMode, locale: $locale, currentIndex: $currentIndex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NavigationStateImpl &&
            (identical(other.pageLabel, pageLabel) ||
                other.pageLabel == pageLabel) &&
            const DeepCollectionEquality()
                .equals(other._navigationItems, _navigationItems) &&
            (identical(other.viewMode, viewMode) ||
                other.viewMode == viewMode) &&
            (identical(other.locale, locale) || other.locale == locale) &&
            (identical(other.currentIndex, currentIndex) ||
                other.currentIndex == currentIndex));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      pageLabel,
      const DeepCollectionEquality().hash(_navigationItems),
      viewMode,
      locale,
      currentIndex);

  /// Create a copy of NavigationState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NavigationStateImplCopyWith<_$NavigationStateImpl> get copyWith =>
      __$$NavigationStateImplCopyWithImpl<_$NavigationStateImpl>(
          this, _$identity);
}

abstract class _NavigationState implements NavigationState {
  const factory _NavigationState(
      {required final PageLabel pageLabel,
      required final List<NavigationItem> navigationItems,
      required final ViewMode viewMode,
      required final String? locale,
      required final int currentIndex}) = _$NavigationStateImpl;

  @override
  PageLabel get pageLabel;
  @override
  List<NavigationItem> get navigationItems;
  @override
  ViewMode get viewMode;
  @override
  String? get locale;
  @override
  int get currentIndex;

  /// Create a copy of NavigationState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NavigationStateImplCopyWith<_$NavigationStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GroupsState {
  List<Group> get value => throw _privateConstructorUsedError;

  /// Create a copy of GroupsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GroupsStateCopyWith<GroupsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GroupsStateCopyWith<$Res> {
  factory $GroupsStateCopyWith(
          GroupsState value, $Res Function(GroupsState) then) =
      _$GroupsStateCopyWithImpl<$Res, GroupsState>;
  @useResult
  $Res call({List<Group> value});
}

/// @nodoc
class _$GroupsStateCopyWithImpl<$Res, $Val extends GroupsState>
    implements $GroupsStateCopyWith<$Res> {
  _$GroupsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GroupsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as List<Group>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GroupsStateImplCopyWith<$Res>
    implements $GroupsStateCopyWith<$Res> {
  factory _$$GroupsStateImplCopyWith(
          _$GroupsStateImpl value, $Res Function(_$GroupsStateImpl) then) =
      __$$GroupsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<Group> value});
}

/// @nodoc
class __$$GroupsStateImplCopyWithImpl<$Res>
    extends _$GroupsStateCopyWithImpl<$Res, _$GroupsStateImpl>
    implements _$$GroupsStateImplCopyWith<$Res> {
  __$$GroupsStateImplCopyWithImpl(
      _$GroupsStateImpl _value, $Res Function(_$GroupsStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of GroupsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$GroupsStateImpl(
      value: null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<Group>,
    ));
  }
}

/// @nodoc

class _$GroupsStateImpl implements _GroupsState {
  const _$GroupsStateImpl({required final List<Group> value}) : _value = value;

  final List<Group> _value;
  @override
  List<Group> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @override
  String toString() {
    return 'GroupsState(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GroupsStateImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  /// Create a copy of GroupsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GroupsStateImplCopyWith<_$GroupsStateImpl> get copyWith =>
      __$$GroupsStateImplCopyWithImpl<_$GroupsStateImpl>(this, _$identity);
}

abstract class _GroupsState implements GroupsState {
  const factory _GroupsState({required final List<Group> value}) =
      _$GroupsStateImpl;

  @override
  List<Group> get value;

  /// Create a copy of GroupsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GroupsStateImplCopyWith<_$GroupsStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NavigationItemsState {
  List<NavigationItem> get value => throw _privateConstructorUsedError;

  /// Create a copy of NavigationItemsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NavigationItemsStateCopyWith<NavigationItemsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NavigationItemsStateCopyWith<$Res> {
  factory $NavigationItemsStateCopyWith(NavigationItemsState value,
          $Res Function(NavigationItemsState) then) =
      _$NavigationItemsStateCopyWithImpl<$Res, NavigationItemsState>;
  @useResult
  $Res call({List<NavigationItem> value});
}

/// @nodoc
class _$NavigationItemsStateCopyWithImpl<$Res,
        $Val extends NavigationItemsState>
    implements $NavigationItemsStateCopyWith<$Res> {
  _$NavigationItemsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NavigationItemsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NavigationItemsStateImplCopyWith<$Res>
    implements $NavigationItemsStateCopyWith<$Res> {
  factory _$$NavigationItemsStateImplCopyWith(_$NavigationItemsStateImpl value,
          $Res Function(_$NavigationItemsStateImpl) then) =
      __$$NavigationItemsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<NavigationItem> value});
}

/// @nodoc
class __$$NavigationItemsStateImplCopyWithImpl<$Res>
    extends _$NavigationItemsStateCopyWithImpl<$Res, _$NavigationItemsStateImpl>
    implements _$$NavigationItemsStateImplCopyWith<$Res> {
  __$$NavigationItemsStateImplCopyWithImpl(_$NavigationItemsStateImpl _value,
      $Res Function(_$NavigationItemsStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of NavigationItemsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NavigationItemsStateImpl(
      value: null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
    ));
  }
}

/// @nodoc

class _$NavigationItemsStateImpl implements _NavigationItemsState {
  const _$NavigationItemsStateImpl({required final List<NavigationItem> value})
      : _value = value;

  final List<NavigationItem> _value;
  @override
  List<NavigationItem> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @override
  String toString() {
    return 'NavigationItemsState(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NavigationItemsStateImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  /// Create a copy of NavigationItemsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NavigationItemsStateImplCopyWith<_$NavigationItemsStateImpl>
      get copyWith =>
          __$$NavigationItemsStateImplCopyWithImpl<_$NavigationItemsStateImpl>(
              this, _$identity);
}

abstract class _NavigationItemsState implements NavigationItemsState {
  const factory _NavigationItemsState(
      {required final List<NavigationItem> value}) = _$NavigationItemsStateImpl;

  @override
  List<NavigationItem> get value;

  /// Create a copy of NavigationItemsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NavigationItemsStateImplCopyWith<_$NavigationItemsStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxiesListState {
  List<Group> get groups => throw _privateConstructorUsedError;
  Set<String> get currentUnfoldSet => throw _privateConstructorUsedError;
  ProxiesSortType get proxiesSortType => throw _privateConstructorUsedError;
  ProxyCardType get proxyCardType => throw _privateConstructorUsedError;
  num get sortNum => throw _privateConstructorUsedError;
  int get columns => throw _privateConstructorUsedError;

  /// Create a copy of ProxiesListState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProxiesListStateCopyWith<ProxiesListState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxiesListStateCopyWith<$Res> {
  factory $ProxiesListStateCopyWith(
          ProxiesListState value, $Res Function(ProxiesListState) then) =
      _$ProxiesListStateCopyWithImpl<$Res, ProxiesListState>;
  @useResult
  $Res call(
      {List<Group> groups,
      Set<String> currentUnfoldSet,
      ProxiesSortType proxiesSortType,
      ProxyCardType proxyCardType,
      num sortNum,
      int columns});
}

/// @nodoc
class _$ProxiesListStateCopyWithImpl<$Res, $Val extends ProxiesListState>
    implements $ProxiesListStateCopyWith<$Res> {
  _$ProxiesListStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProxiesListState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groups = null,
    Object? currentUnfoldSet = null,
    Object? proxiesSortType = null,
    Object? proxyCardType = null,
    Object? sortNum = null,
    Object? columns = null,
  }) {
    return _then(_value.copyWith(
      groups: null == groups
          ? _value.groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Group>,
      currentUnfoldSet: null == currentUnfoldSet
          ? _value.currentUnfoldSet
          : currentUnfoldSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      proxiesSortType: null == proxiesSortType
          ? _value.proxiesSortType
          : proxiesSortType // ignore: cast_nullable_to_non_nullable
              as ProxiesSortType,
      proxyCardType: null == proxyCardType
          ? _value.proxyCardType
          : proxyCardType // ignore: cast_nullable_to_non_nullable
              as ProxyCardType,
      sortNum: null == sortNum
          ? _value.sortNum
          : sortNum // ignore: cast_nullable_to_non_nullable
              as num,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxiesListStateImplCopyWith<$Res>
    implements $ProxiesListStateCopyWith<$Res> {
  factory _$$ProxiesListStateImplCopyWith(_$ProxiesListStateImpl value,
          $Res Function(_$ProxiesListStateImpl) then) =
      __$$ProxiesListStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Group> groups,
      Set<String> currentUnfoldSet,
      ProxiesSortType proxiesSortType,
      ProxyCardType proxyCardType,
      num sortNum,
      int columns});
}

/// @nodoc
class __$$ProxiesListStateImplCopyWithImpl<$Res>
    extends _$ProxiesListStateCopyWithImpl<$Res, _$ProxiesListStateImpl>
    implements _$$ProxiesListStateImplCopyWith<$Res> {
  __$$ProxiesListStateImplCopyWithImpl(_$ProxiesListStateImpl _value,
      $Res Function(_$ProxiesListStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProxiesListState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groups = null,
    Object? currentUnfoldSet = null,
    Object? proxiesSortType = null,
    Object? proxyCardType = null,
    Object? sortNum = null,
    Object? columns = null,
  }) {
    return _then(_$ProxiesListStateImpl(
      groups: null == groups
          ? _value._groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Group>,
      currentUnfoldSet: null == currentUnfoldSet
          ? _value._currentUnfoldSet
          : currentUnfoldSet // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      proxiesSortType: null == proxiesSortType
          ? _value.proxiesSortType
          : proxiesSortType // ignore: cast_nullable_to_non_nullable
              as ProxiesSortType,
      proxyCardType: null == proxyCardType
          ? _value.proxyCardType
          : proxyCardType // ignore: cast_nullable_to_non_nullable
              as ProxyCardType,
      sortNum: null == sortNum
          ? _value.sortNum
          : sortNum // ignore: cast_nullable_to_non_nullable
              as num,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ProxiesListStateImpl implements _ProxiesListState {
  const _$ProxiesListStateImpl(
      {required final List<Group> groups,
      required final Set<String> currentUnfoldSet,
      required this.proxiesSortType,
      required this.proxyCardType,
      required this.sortNum,
      required this.columns})
      : _groups = groups,
        _currentUnfoldSet = currentUnfoldSet;

  final List<Group> _groups;
  @override
  List<Group> get groups {
    if (_groups is EqualUnmodifiableListView) return _groups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_groups);
  }

  final Set<String> _currentUnfoldSet;
  @override
  Set<String> get currentUnfoldSet {
    if (_currentUnfoldSet is EqualUnmodifiableSetView) return _currentUnfoldSet;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_currentUnfoldSet);
  }

  @override
  final ProxiesSortType proxiesSortType;
  @override
  final ProxyCardType proxyCardType;
  @override
  final num sortNum;
  @override
  final int columns;

  @override
  String toString() {
    return 'ProxiesListState(groups: $groups, currentUnfoldSet: $currentUnfoldSet, proxiesSortType: $proxiesSortType, proxyCardType: $proxyCardType, sortNum: $sortNum, columns: $columns)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxiesListStateImpl &&
            const DeepCollectionEquality().equals(other._groups, _groups) &&
            const DeepCollectionEquality()
                .equals(other._currentUnfoldSet, _currentUnfoldSet) &&
            (identical(other.proxiesSortType, proxiesSortType) ||
                other.proxiesSortType == proxiesSortType) &&
            (identical(other.proxyCardType, proxyCardType) ||
                other.proxyCardType == proxyCardType) &&
            (identical(other.sortNum, sortNum) || other.sortNum == sortNum) &&
            (identical(other.columns, columns) || other.columns == columns));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_groups),
      const DeepCollectionEquality().hash(_currentUnfoldSet),
      proxiesSortType,
      proxyCardType,
      sortNum,
      columns);

  /// Create a copy of ProxiesListState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxiesListStateImplCopyWith<_$ProxiesListStateImpl> get copyWith =>
      __$$ProxiesListStateImplCopyWithImpl<_$ProxiesListStateImpl>(
          this, _$identity);
}

abstract class _ProxiesListState implements ProxiesListState {
  const factory _ProxiesListState(
      {required final List<Group> groups,
      required final Set<String> currentUnfoldSet,
      required final ProxiesSortType proxiesSortType,
      required final ProxyCardType proxyCardType,
      required final num sortNum,
      required final int columns}) = _$ProxiesListStateImpl;

  @override
  List<Group> get groups;
  @override
  Set<String> get currentUnfoldSet;
  @override
  ProxiesSortType get proxiesSortType;
  @override
  ProxyCardType get proxyCardType;
  @override
  num get sortNum;
  @override
  int get columns;

  /// Create a copy of ProxiesListState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProxiesListStateImplCopyWith<_$ProxiesListStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxiesTabState {
  List<Group> get groups => throw _privateConstructorUsedError;
  String? get currentGroupName => throw _privateConstructorUsedError;
  ProxiesSortType get proxiesSortType => throw _privateConstructorUsedError;
  ProxyCardType get proxyCardType => throw _privateConstructorUsedError;
  num get sortNum => throw _privateConstructorUsedError;
  int get columns => throw _privateConstructorUsedError;

  /// Create a copy of ProxiesTabState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProxiesTabStateCopyWith<ProxiesTabState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxiesTabStateCopyWith<$Res> {
  factory $ProxiesTabStateCopyWith(
          ProxiesTabState value, $Res Function(ProxiesTabState) then) =
      _$ProxiesTabStateCopyWithImpl<$Res, ProxiesTabState>;
  @useResult
  $Res call(
      {List<Group> groups,
      String? currentGroupName,
      ProxiesSortType proxiesSortType,
      ProxyCardType proxyCardType,
      num sortNum,
      int columns});
}

/// @nodoc
class _$ProxiesTabStateCopyWithImpl<$Res, $Val extends ProxiesTabState>
    implements $ProxiesTabStateCopyWith<$Res> {
  _$ProxiesTabStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProxiesTabState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groups = null,
    Object? currentGroupName = freezed,
    Object? proxiesSortType = null,
    Object? proxyCardType = null,
    Object? sortNum = null,
    Object? columns = null,
  }) {
    return _then(_value.copyWith(
      groups: null == groups
          ? _value.groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Group>,
      currentGroupName: freezed == currentGroupName
          ? _value.currentGroupName
          : currentGroupName // ignore: cast_nullable_to_non_nullable
              as String?,
      proxiesSortType: null == proxiesSortType
          ? _value.proxiesSortType
          : proxiesSortType // ignore: cast_nullable_to_non_nullable
              as ProxiesSortType,
      proxyCardType: null == proxyCardType
          ? _value.proxyCardType
          : proxyCardType // ignore: cast_nullable_to_non_nullable
              as ProxyCardType,
      sortNum: null == sortNum
          ? _value.sortNum
          : sortNum // ignore: cast_nullable_to_non_nullable
              as num,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxiesTabStateImplCopyWith<$Res>
    implements $ProxiesTabStateCopyWith<$Res> {
  factory _$$ProxiesTabStateImplCopyWith(_$ProxiesTabStateImpl value,
          $Res Function(_$ProxiesTabStateImpl) then) =
      __$$ProxiesTabStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Group> groups,
      String? currentGroupName,
      ProxiesSortType proxiesSortType,
      ProxyCardType proxyCardType,
      num sortNum,
      int columns});
}

/// @nodoc
class __$$ProxiesTabStateImplCopyWithImpl<$Res>
    extends _$ProxiesTabStateCopyWithImpl<$Res, _$ProxiesTabStateImpl>
    implements _$$ProxiesTabStateImplCopyWith<$Res> {
  __$$ProxiesTabStateImplCopyWithImpl(
      _$ProxiesTabStateImpl _value, $Res Function(_$ProxiesTabStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProxiesTabState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groups = null,
    Object? currentGroupName = freezed,
    Object? proxiesSortType = null,
    Object? proxyCardType = null,
    Object? sortNum = null,
    Object? columns = null,
  }) {
    return _then(_$ProxiesTabStateImpl(
      groups: null == groups
          ? _value._groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Group>,
      currentGroupName: freezed == currentGroupName
          ? _value.currentGroupName
          : currentGroupName // ignore: cast_nullable_to_non_nullable
              as String?,
      proxiesSortType: null == proxiesSortType
          ? _value.proxiesSortType
          : proxiesSortType // ignore: cast_nullable_to_non_nullable
              as ProxiesSortType,
      proxyCardType: null == proxyCardType
          ? _value.proxyCardType
          : proxyCardType // ignore: cast_nullable_to_non_nullable
              as ProxyCardType,
      sortNum: null == sortNum
          ? _value.sortNum
          : sortNum // ignore: cast_nullable_to_non_nullable
              as num,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ProxiesTabStateImpl implements _ProxiesTabState {
  const _$ProxiesTabStateImpl(
      {required final List<Group> groups,
      required this.currentGroupName,
      required this.proxiesSortType,
      required this.proxyCardType,
      required this.sortNum,
      required this.columns})
      : _groups = groups;

  final List<Group> _groups;
  @override
  List<Group> get groups {
    if (_groups is EqualUnmodifiableListView) return _groups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_groups);
  }

  @override
  final String? currentGroupName;
  @override
  final ProxiesSortType proxiesSortType;
  @override
  final ProxyCardType proxyCardType;
  @override
  final num sortNum;
  @override
  final int columns;

  @override
  String toString() {
    return 'ProxiesTabState(groups: $groups, currentGroupName: $currentGroupName, proxiesSortType: $proxiesSortType, proxyCardType: $proxyCardType, sortNum: $sortNum, columns: $columns)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxiesTabStateImpl &&
            const DeepCollectionEquality().equals(other._groups, _groups) &&
            (identical(other.currentGroupName, currentGroupName) ||
                other.currentGroupName == currentGroupName) &&
            (identical(other.proxiesSortType, proxiesSortType) ||
                other.proxiesSortType == proxiesSortType) &&
            (identical(other.proxyCardType, proxyCardType) ||
                other.proxyCardType == proxyCardType) &&
            (identical(other.sortNum, sortNum) || other.sortNum == sortNum) &&
            (identical(other.columns, columns) || other.columns == columns));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_groups),
      currentGroupName,
      proxiesSortType,
      proxyCardType,
      sortNum,
      columns);

  /// Create a copy of ProxiesTabState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxiesTabStateImplCopyWith<_$ProxiesTabStateImpl> get copyWith =>
      __$$ProxiesTabStateImplCopyWithImpl<_$ProxiesTabStateImpl>(
          this, _$identity);
}

abstract class _ProxiesTabState implements ProxiesTabState {
  const factory _ProxiesTabState(
      {required final List<Group> groups,
      required final String? currentGroupName,
      required final ProxiesSortType proxiesSortType,
      required final ProxyCardType proxyCardType,
      required final num sortNum,
      required final int columns}) = _$ProxiesTabStateImpl;

  @override
  List<Group> get groups;
  @override
  String? get currentGroupName;
  @override
  ProxiesSortType get proxiesSortType;
  @override
  ProxyCardType get proxyCardType;
  @override
  num get sortNum;
  @override
  int get columns;

  /// Create a copy of ProxiesTabState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProxiesTabStateImplCopyWith<_$ProxiesTabStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxyGroupSelectorState {
  String? get testUrl => throw _privateConstructorUsedError;
  ProxiesSortType get proxiesSortType => throw _privateConstructorUsedError;
  ProxyCardType get proxyCardType => throw _privateConstructorUsedError;
  num get sortNum => throw _privateConstructorUsedError;
  GroupType get groupType => throw _privateConstructorUsedError;
  List<Proxy> get proxies => throw _privateConstructorUsedError;
  int get columns => throw _privateConstructorUsedError;

  /// Create a copy of ProxyGroupSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProxyGroupSelectorStateCopyWith<ProxyGroupSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxyGroupSelectorStateCopyWith<$Res> {
  factory $ProxyGroupSelectorStateCopyWith(ProxyGroupSelectorState value,
          $Res Function(ProxyGroupSelectorState) then) =
      _$ProxyGroupSelectorStateCopyWithImpl<$Res, ProxyGroupSelectorState>;
  @useResult
  $Res call(
      {String? testUrl,
      ProxiesSortType proxiesSortType,
      ProxyCardType proxyCardType,
      num sortNum,
      GroupType groupType,
      List<Proxy> proxies,
      int columns});
}

/// @nodoc
class _$ProxyGroupSelectorStateCopyWithImpl<$Res,
        $Val extends ProxyGroupSelectorState>
    implements $ProxyGroupSelectorStateCopyWith<$Res> {
  _$ProxyGroupSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProxyGroupSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? testUrl = freezed,
    Object? proxiesSortType = null,
    Object? proxyCardType = null,
    Object? sortNum = null,
    Object? groupType = null,
    Object? proxies = null,
    Object? columns = null,
  }) {
    return _then(_value.copyWith(
      testUrl: freezed == testUrl
          ? _value.testUrl
          : testUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      proxiesSortType: null == proxiesSortType
          ? _value.proxiesSortType
          : proxiesSortType // ignore: cast_nullable_to_non_nullable
              as ProxiesSortType,
      proxyCardType: null == proxyCardType
          ? _value.proxyCardType
          : proxyCardType // ignore: cast_nullable_to_non_nullable
              as ProxyCardType,
      sortNum: null == sortNum
          ? _value.sortNum
          : sortNum // ignore: cast_nullable_to_non_nullable
              as num,
      groupType: null == groupType
          ? _value.groupType
          : groupType // ignore: cast_nullable_to_non_nullable
              as GroupType,
      proxies: null == proxies
          ? _value.proxies
          : proxies // ignore: cast_nullable_to_non_nullable
              as List<Proxy>,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxyGroupSelectorStateImplCopyWith<$Res>
    implements $ProxyGroupSelectorStateCopyWith<$Res> {
  factory _$$ProxyGroupSelectorStateImplCopyWith(
          _$ProxyGroupSelectorStateImpl value,
          $Res Function(_$ProxyGroupSelectorStateImpl) then) =
      __$$ProxyGroupSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? testUrl,
      ProxiesSortType proxiesSortType,
      ProxyCardType proxyCardType,
      num sortNum,
      GroupType groupType,
      List<Proxy> proxies,
      int columns});
}

/// @nodoc
class __$$ProxyGroupSelectorStateImplCopyWithImpl<$Res>
    extends _$ProxyGroupSelectorStateCopyWithImpl<$Res,
        _$ProxyGroupSelectorStateImpl>
    implements _$$ProxyGroupSelectorStateImplCopyWith<$Res> {
  __$$ProxyGroupSelectorStateImplCopyWithImpl(
      _$ProxyGroupSelectorStateImpl _value,
      $Res Function(_$ProxyGroupSelectorStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProxyGroupSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? testUrl = freezed,
    Object? proxiesSortType = null,
    Object? proxyCardType = null,
    Object? sortNum = null,
    Object? groupType = null,
    Object? proxies = null,
    Object? columns = null,
  }) {
    return _then(_$ProxyGroupSelectorStateImpl(
      testUrl: freezed == testUrl
          ? _value.testUrl
          : testUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      proxiesSortType: null == proxiesSortType
          ? _value.proxiesSortType
          : proxiesSortType // ignore: cast_nullable_to_non_nullable
              as ProxiesSortType,
      proxyCardType: null == proxyCardType
          ? _value.proxyCardType
          : proxyCardType // ignore: cast_nullable_to_non_nullable
              as ProxyCardType,
      sortNum: null == sortNum
          ? _value.sortNum
          : sortNum // ignore: cast_nullable_to_non_nullable
              as num,
      groupType: null == groupType
          ? _value.groupType
          : groupType // ignore: cast_nullable_to_non_nullable
              as GroupType,
      proxies: null == proxies
          ? _value._proxies
          : proxies // ignore: cast_nullable_to_non_nullable
              as List<Proxy>,
      columns: null == columns
          ? _value.columns
          : columns // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ProxyGroupSelectorStateImpl implements _ProxyGroupSelectorState {
  const _$ProxyGroupSelectorStateImpl(
      {required this.testUrl,
      required this.proxiesSortType,
      required this.proxyCardType,
      required this.sortNum,
      required this.groupType,
      required final List<Proxy> proxies,
      required this.columns})
      : _proxies = proxies;

  @override
  final String? testUrl;
  @override
  final ProxiesSortType proxiesSortType;
  @override
  final ProxyCardType proxyCardType;
  @override
  final num sortNum;
  @override
  final GroupType groupType;
  final List<Proxy> _proxies;
  @override
  List<Proxy> get proxies {
    if (_proxies is EqualUnmodifiableListView) return _proxies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_proxies);
  }

  @override
  final int columns;

  @override
  String toString() {
    return 'ProxyGroupSelectorState(testUrl: $testUrl, proxiesSortType: $proxiesSortType, proxyCardType: $proxyCardType, sortNum: $sortNum, groupType: $groupType, proxies: $proxies, columns: $columns)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxyGroupSelectorStateImpl &&
            (identical(other.testUrl, testUrl) || other.testUrl == testUrl) &&
            (identical(other.proxiesSortType, proxiesSortType) ||
                other.proxiesSortType == proxiesSortType) &&
            (identical(other.proxyCardType, proxyCardType) ||
                other.proxyCardType == proxyCardType) &&
            (identical(other.sortNum, sortNum) || other.sortNum == sortNum) &&
            (identical(other.groupType, groupType) ||
                other.groupType == groupType) &&
            const DeepCollectionEquality().equals(other._proxies, _proxies) &&
            (identical(other.columns, columns) || other.columns == columns));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      testUrl,
      proxiesSortType,
      proxyCardType,
      sortNum,
      groupType,
      const DeepCollectionEquality().hash(_proxies),
      columns);

  /// Create a copy of ProxyGroupSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxyGroupSelectorStateImplCopyWith<_$ProxyGroupSelectorStateImpl>
      get copyWith => __$$ProxyGroupSelectorStateImplCopyWithImpl<
          _$ProxyGroupSelectorStateImpl>(this, _$identity);
}

abstract class _ProxyGroupSelectorState implements ProxyGroupSelectorState {
  const factory _ProxyGroupSelectorState(
      {required final String? testUrl,
      required final ProxiesSortType proxiesSortType,
      required final ProxyCardType proxyCardType,
      required final num sortNum,
      required final GroupType groupType,
      required final List<Proxy> proxies,
      required final int columns}) = _$ProxyGroupSelectorStateImpl;

  @override
  String? get testUrl;
  @override
  ProxiesSortType get proxiesSortType;
  @override
  ProxyCardType get proxyCardType;
  @override
  num get sortNum;
  @override
  GroupType get groupType;
  @override
  List<Proxy> get proxies;
  @override
  int get columns;

  /// Create a copy of ProxyGroupSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProxyGroupSelectorStateImplCopyWith<_$ProxyGroupSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MoreToolsSelectorState {
  List<NavigationItem> get navigationItems =>
      throw _privateConstructorUsedError;

  /// Create a copy of MoreToolsSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MoreToolsSelectorStateCopyWith<MoreToolsSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MoreToolsSelectorStateCopyWith<$Res> {
  factory $MoreToolsSelectorStateCopyWith(MoreToolsSelectorState value,
          $Res Function(MoreToolsSelectorState) then) =
      _$MoreToolsSelectorStateCopyWithImpl<$Res, MoreToolsSelectorState>;
  @useResult
  $Res call({List<NavigationItem> navigationItems});
}

/// @nodoc
class _$MoreToolsSelectorStateCopyWithImpl<$Res,
        $Val extends MoreToolsSelectorState>
    implements $MoreToolsSelectorStateCopyWith<$Res> {
  _$MoreToolsSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MoreToolsSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? navigationItems = null,
  }) {
    return _then(_value.copyWith(
      navigationItems: null == navigationItems
          ? _value.navigationItems
          : navigationItems // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MoreToolsSelectorStateImplCopyWith<$Res>
    implements $MoreToolsSelectorStateCopyWith<$Res> {
  factory _$$MoreToolsSelectorStateImplCopyWith(
          _$MoreToolsSelectorStateImpl value,
          $Res Function(_$MoreToolsSelectorStateImpl) then) =
      __$$MoreToolsSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<NavigationItem> navigationItems});
}

/// @nodoc
class __$$MoreToolsSelectorStateImplCopyWithImpl<$Res>
    extends _$MoreToolsSelectorStateCopyWithImpl<$Res,
        _$MoreToolsSelectorStateImpl>
    implements _$$MoreToolsSelectorStateImplCopyWith<$Res> {
  __$$MoreToolsSelectorStateImplCopyWithImpl(
      _$MoreToolsSelectorStateImpl _value,
      $Res Function(_$MoreToolsSelectorStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of MoreToolsSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? navigationItems = null,
  }) {
    return _then(_$MoreToolsSelectorStateImpl(
      navigationItems: null == navigationItems
          ? _value._navigationItems
          : navigationItems // ignore: cast_nullable_to_non_nullable
              as List<NavigationItem>,
    ));
  }
}

/// @nodoc

class _$MoreToolsSelectorStateImpl implements _MoreToolsSelectorState {
  const _$MoreToolsSelectorStateImpl(
      {required final List<NavigationItem> navigationItems})
      : _navigationItems = navigationItems;

  final List<NavigationItem> _navigationItems;
  @override
  List<NavigationItem> get navigationItems {
    if (_navigationItems is EqualUnmodifiableListView) return _navigationItems;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_navigationItems);
  }

  @override
  String toString() {
    return 'MoreToolsSelectorState(navigationItems: $navigationItems)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MoreToolsSelectorStateImpl &&
            const DeepCollectionEquality()
                .equals(other._navigationItems, _navigationItems));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_navigationItems));

  /// Create a copy of MoreToolsSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MoreToolsSelectorStateImplCopyWith<_$MoreToolsSelectorStateImpl>
      get copyWith => __$$MoreToolsSelectorStateImplCopyWithImpl<
          _$MoreToolsSelectorStateImpl>(this, _$identity);
}

abstract class _MoreToolsSelectorState implements MoreToolsSelectorState {
  const factory _MoreToolsSelectorState(
          {required final List<NavigationItem> navigationItems}) =
      _$MoreToolsSelectorStateImpl;

  @override
  List<NavigationItem> get navigationItems;

  /// Create a copy of MoreToolsSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MoreToolsSelectorStateImplCopyWith<_$MoreToolsSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PackageListSelectorState {
  List<Package> get packages => throw _privateConstructorUsedError;
  AccessControl get accessControl => throw _privateConstructorUsedError;

  /// Create a copy of PackageListSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PackageListSelectorStateCopyWith<PackageListSelectorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackageListSelectorStateCopyWith<$Res> {
  factory $PackageListSelectorStateCopyWith(PackageListSelectorState value,
          $Res Function(PackageListSelectorState) then) =
      _$PackageListSelectorStateCopyWithImpl<$Res, PackageListSelectorState>;
  @useResult
  $Res call({List<Package> packages, AccessControl accessControl});

  $AccessControlCopyWith<$Res> get accessControl;
}

/// @nodoc
class _$PackageListSelectorStateCopyWithImpl<$Res,
        $Val extends PackageListSelectorState>
    implements $PackageListSelectorStateCopyWith<$Res> {
  _$PackageListSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PackageListSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? packages = null,
    Object? accessControl = null,
  }) {
    return _then(_value.copyWith(
      packages: null == packages
          ? _value.packages
          : packages // ignore: cast_nullable_to_non_nullable
              as List<Package>,
      accessControl: null == accessControl
          ? _value.accessControl
          : accessControl // ignore: cast_nullable_to_non_nullable
              as AccessControl,
    ) as $Val);
  }

  /// Create a copy of PackageListSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccessControlCopyWith<$Res> get accessControl {
    return $AccessControlCopyWith<$Res>(_value.accessControl, (value) {
      return _then(_value.copyWith(accessControl: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PackageListSelectorStateImplCopyWith<$Res>
    implements $PackageListSelectorStateCopyWith<$Res> {
  factory _$$PackageListSelectorStateImplCopyWith(
          _$PackageListSelectorStateImpl value,
          $Res Function(_$PackageListSelectorStateImpl) then) =
      __$$PackageListSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<Package> packages, AccessControl accessControl});

  @override
  $AccessControlCopyWith<$Res> get accessControl;
}

/// @nodoc
class __$$PackageListSelectorStateImplCopyWithImpl<$Res>
    extends _$PackageListSelectorStateCopyWithImpl<$Res,
        _$PackageListSelectorStateImpl>
    implements _$$PackageListSelectorStateImplCopyWith<$Res> {
  __$$PackageListSelectorStateImplCopyWithImpl(
      _$PackageListSelectorStateImpl _value,
      $Res Function(_$PackageListSelectorStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of PackageListSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? packages = null,
    Object? accessControl = null,
  }) {
    return _then(_$PackageListSelectorStateImpl(
      packages: null == packages
          ? _value._packages
          : packages // ignore: cast_nullable_to_non_nullable
              as List<Package>,
      accessControl: null == accessControl
          ? _value.accessControl
          : accessControl // ignore: cast_nullable_to_non_nullable
              as AccessControl,
    ));
  }
}

/// @nodoc

class _$PackageListSelectorStateImpl implements _PackageListSelectorState {
  const _$PackageListSelectorStateImpl(
      {required final List<Package> packages, required this.accessControl})
      : _packages = packages;

  final List<Package> _packages;
  @override
  List<Package> get packages {
    if (_packages is EqualUnmodifiableListView) return _packages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_packages);
  }

  @override
  final AccessControl accessControl;

  @override
  String toString() {
    return 'PackageListSelectorState(packages: $packages, accessControl: $accessControl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PackageListSelectorStateImpl &&
            const DeepCollectionEquality().equals(other._packages, _packages) &&
            (identical(other.accessControl, accessControl) ||
                other.accessControl == accessControl));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_packages), accessControl);

  /// Create a copy of PackageListSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PackageListSelectorStateImplCopyWith<_$PackageListSelectorStateImpl>
      get copyWith => __$$PackageListSelectorStateImplCopyWithImpl<
          _$PackageListSelectorStateImpl>(this, _$identity);
}

abstract class _PackageListSelectorState implements PackageListSelectorState {
  const factory _PackageListSelectorState(
          {required final List<Package> packages,
          required final AccessControl accessControl}) =
      _$PackageListSelectorStateImpl;

  @override
  List<Package> get packages;
  @override
  AccessControl get accessControl;

  /// Create a copy of PackageListSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PackageListSelectorStateImplCopyWith<_$PackageListSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxiesListHeaderSelectorState {
  double get offset => throw _privateConstructorUsedError;
  int get currentIndex => throw _privateConstructorUsedError;

  /// Create a copy of ProxiesListHeaderSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProxiesListHeaderSelectorStateCopyWith<ProxiesListHeaderSelectorState>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxiesListHeaderSelectorStateCopyWith<$Res> {
  factory $ProxiesListHeaderSelectorStateCopyWith(
          ProxiesListHeaderSelectorState value,
          $Res Function(ProxiesListHeaderSelectorState) then) =
      _$ProxiesListHeaderSelectorStateCopyWithImpl<$Res,
          ProxiesListHeaderSelectorState>;
  @useResult
  $Res call({double offset, int currentIndex});
}

/// @nodoc
class _$ProxiesListHeaderSelectorStateCopyWithImpl<$Res,
        $Val extends ProxiesListHeaderSelectorState>
    implements $ProxiesListHeaderSelectorStateCopyWith<$Res> {
  _$ProxiesListHeaderSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProxiesListHeaderSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? currentIndex = null,
  }) {
    return _then(_value.copyWith(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as double,
      currentIndex: null == currentIndex
          ? _value.currentIndex
          : currentIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxiesListHeaderSelectorStateImplCopyWith<$Res>
    implements $ProxiesListHeaderSelectorStateCopyWith<$Res> {
  factory _$$ProxiesListHeaderSelectorStateImplCopyWith(
          _$ProxiesListHeaderSelectorStateImpl value,
          $Res Function(_$ProxiesListHeaderSelectorStateImpl) then) =
      __$$ProxiesListHeaderSelectorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double offset, int currentIndex});
}

/// @nodoc
class __$$ProxiesListHeaderSelectorStateImplCopyWithImpl<$Res>
    extends _$ProxiesListHeaderSelectorStateCopyWithImpl<$Res,
        _$ProxiesListHeaderSelectorStateImpl>
    implements _$$ProxiesListHeaderSelectorStateImplCopyWith<$Res> {
  __$$ProxiesListHeaderSelectorStateImplCopyWithImpl(
      _$ProxiesListHeaderSelectorStateImpl _value,
      $Res Function(_$ProxiesListHeaderSelectorStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProxiesListHeaderSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? currentIndex = null,
  }) {
    return _then(_$ProxiesListHeaderSelectorStateImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as double,
      currentIndex: null == currentIndex
          ? _value.currentIndex
          : currentIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ProxiesListHeaderSelectorStateImpl
    implements _ProxiesListHeaderSelectorState {
  const _$ProxiesListHeaderSelectorStateImpl(
      {required this.offset, required this.currentIndex});

  @override
  final double offset;
  @override
  final int currentIndex;

  @override
  String toString() {
    return 'ProxiesListHeaderSelectorState(offset: $offset, currentIndex: $currentIndex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxiesListHeaderSelectorStateImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.currentIndex, currentIndex) ||
                other.currentIndex == currentIndex));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, currentIndex);

  /// Create a copy of ProxiesListHeaderSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxiesListHeaderSelectorStateImplCopyWith<
          _$ProxiesListHeaderSelectorStateImpl>
      get copyWith => __$$ProxiesListHeaderSelectorStateImplCopyWithImpl<
          _$ProxiesListHeaderSelectorStateImpl>(this, _$identity);
}

abstract class _ProxiesListHeaderSelectorState
    implements ProxiesListHeaderSelectorState {
  const factory _ProxiesListHeaderSelectorState(
      {required final double offset,
      required final int currentIndex}) = _$ProxiesListHeaderSelectorStateImpl;

  @override
  double get offset;
  @override
  int get currentIndex;

  /// Create a copy of ProxiesListHeaderSelectorState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProxiesListHeaderSelectorStateImplCopyWith<
          _$ProxiesListHeaderSelectorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxiesActionsState {
  PageLabel get pageLabel => throw _privateConstructorUsedError;
  ProxiesType get type => throw _privateConstructorUsedError;
  bool get hasProviders => throw _privateConstructorUsedError;

  /// Create a copy of ProxiesActionsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProxiesActionsStateCopyWith<ProxiesActionsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxiesActionsStateCopyWith<$Res> {
  factory $ProxiesActionsStateCopyWith(
          ProxiesActionsState value, $Res Function(ProxiesActionsState) then) =
      _$ProxiesActionsStateCopyWithImpl<$Res, ProxiesActionsState>;
  @useResult
  $Res call({PageLabel pageLabel, ProxiesType type, bool hasProviders});
}

/// @nodoc
class _$ProxiesActionsStateCopyWithImpl<$Res, $Val extends ProxiesActionsState>
    implements $ProxiesActionsStateCopyWith<$Res> {
  _$ProxiesActionsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProxiesActionsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageLabel = null,
    Object? type = null,
    Object? hasProviders = null,
  }) {
    return _then(_value.copyWith(
      pageLabel: null == pageLabel
          ? _value.pageLabel
          : pageLabel // ignore: cast_nullable_to_non_nullable
              as PageLabel,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ProxiesType,
      hasProviders: null == hasProviders
          ? _value.hasProviders
          : hasProviders // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxiesActionsStateImplCopyWith<$Res>
    implements $ProxiesActionsStateCopyWith<$Res> {
  factory _$$ProxiesActionsStateImplCopyWith(_$ProxiesActionsStateImpl value,
          $Res Function(_$ProxiesActionsStateImpl) then) =
      __$$ProxiesActionsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({PageLabel pageLabel, ProxiesType type, bool hasProviders});
}

/// @nodoc
class __$$ProxiesActionsStateImplCopyWithImpl<$Res>
    extends _$ProxiesActionsStateCopyWithImpl<$Res, _$ProxiesActionsStateImpl>
    implements _$$ProxiesActionsStateImplCopyWith<$Res> {
  __$$ProxiesActionsStateImplCopyWithImpl(_$ProxiesActionsStateImpl _value,
      $Res Function(_$ProxiesActionsStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProxiesActionsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageLabel = null,
    Object? type = null,
    Object? hasProviders = null,
  }) {
    return _then(_$ProxiesActionsStateImpl(
      pageLabel: null == pageLabel
          ? _value.pageLabel
          : pageLabel // ignore: cast_nullable_to_non_nullable
              as PageLabel,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ProxiesType,
      hasProviders: null == hasProviders
          ? _value.hasProviders
          : hasProviders // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ProxiesActionsStateImpl implements _ProxiesActionsState {
  const _$ProxiesActionsStateImpl(
      {required this.pageLabel,
      required this.type,
      required this.hasProviders});

  @override
  final PageLabel pageLabel;
  @override
  final ProxiesType type;
  @override
  final bool hasProviders;

  @override
  String toString() {
    return 'ProxiesActionsState(pageLabel: $pageLabel, type: $type, hasProviders: $hasProviders)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxiesActionsStateImpl &&
            (identical(other.pageLabel, pageLabel) ||
                other.pageLabel == pageLabel) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.hasProviders, hasProviders) ||
                other.hasProviders == hasProviders));
  }

  @override
  int get hashCode => Object.hash(runtimeType, pageLabel, type, hasProviders);

  /// Create a copy of ProxiesActionsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxiesActionsStateImplCopyWith<_$ProxiesActionsStateImpl> get copyWith =>
      __$$ProxiesActionsStateImplCopyWithImpl<_$ProxiesActionsStateImpl>(
          this, _$identity);
}

abstract class _ProxiesActionsState implements ProxiesActionsState {
  const factory _ProxiesActionsState(
      {required final PageLabel pageLabel,
      required final ProxiesType type,
      required final bool hasProviders}) = _$ProxiesActionsStateImpl;

  @override
  PageLabel get pageLabel;
  @override
  ProxiesType get type;
  @override
  bool get hasProviders;

  /// Create a copy of ProxiesActionsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProxiesActionsStateImplCopyWith<_$ProxiesActionsStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxyState {
  bool get isStart => throw _privateConstructorUsedError;
  bool get systemProxy => throw _privateConstructorUsedError;
  List<String> get bassDomain => throw _privateConstructorUsedError;
  int get port => throw _privateConstructorUsedError;

  /// Create a copy of ProxyState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProxyStateCopyWith<ProxyState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxyStateCopyWith<$Res> {
  factory $ProxyStateCopyWith(
          ProxyState value, $Res Function(ProxyState) then) =
      _$ProxyStateCopyWithImpl<$Res, ProxyState>;
  @useResult
  $Res call(
      {bool isStart, bool systemProxy, List<String> bassDomain, int port});
}

/// @nodoc
class _$ProxyStateCopyWithImpl<$Res, $Val extends ProxyState>
    implements $ProxyStateCopyWith<$Res> {
  _$ProxyStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProxyState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isStart = null,
    Object? systemProxy = null,
    Object? bassDomain = null,
    Object? port = null,
  }) {
    return _then(_value.copyWith(
      isStart: null == isStart
          ? _value.isStart
          : isStart // ignore: cast_nullable_to_non_nullable
              as bool,
      systemProxy: null == systemProxy
          ? _value.systemProxy
          : systemProxy // ignore: cast_nullable_to_non_nullable
              as bool,
      bassDomain: null == bassDomain
          ? _value.bassDomain
          : bassDomain // ignore: cast_nullable_to_non_nullable
              as List<String>,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxyStateImplCopyWith<$Res>
    implements $ProxyStateCopyWith<$Res> {
  factory _$$ProxyStateImplCopyWith(
          _$ProxyStateImpl value, $Res Function(_$ProxyStateImpl) then) =
      __$$ProxyStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isStart, bool systemProxy, List<String> bassDomain, int port});
}

/// @nodoc
class __$$ProxyStateImplCopyWithImpl<$Res>
    extends _$ProxyStateCopyWithImpl<$Res, _$ProxyStateImpl>
    implements _$$ProxyStateImplCopyWith<$Res> {
  __$$ProxyStateImplCopyWithImpl(
      _$ProxyStateImpl _value, $Res Function(_$ProxyStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProxyState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isStart = null,
    Object? systemProxy = null,
    Object? bassDomain = null,
    Object? port = null,
  }) {
    return _then(_$ProxyStateImpl(
      isStart: null == isStart
          ? _value.isStart
          : isStart // ignore: cast_nullable_to_non_nullable
              as bool,
      systemProxy: null == systemProxy
          ? _value.systemProxy
          : systemProxy // ignore: cast_nullable_to_non_nullable
              as bool,
      bassDomain: null == bassDomain
          ? _value._bassDomain
          : bassDomain // ignore: cast_nullable_to_non_nullable
              as List<String>,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ProxyStateImpl implements _ProxyState {
  const _$ProxyStateImpl(
      {required this.isStart,
      required this.systemProxy,
      required final List<String> bassDomain,
      required this.port})
      : _bassDomain = bassDomain;

  @override
  final bool isStart;
  @override
  final bool systemProxy;
  final List<String> _bassDomain;
  @override
  List<String> get bassDomain {
    if (_bassDomain is EqualUnmodifiableListView) return _bassDomain;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_bassDomain);
  }

  @override
  final int port;

  @override
  String toString() {
    return 'ProxyState(isStart: $isStart, systemProxy: $systemProxy, bassDomain: $bassDomain, port: $port)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxyStateImpl &&
            (identical(other.isStart, isStart) || other.isStart == isStart) &&
            (identical(other.systemProxy, systemProxy) ||
                other.systemProxy == systemProxy) &&
            const DeepCollectionEquality()
                .equals(other._bassDomain, _bassDomain) &&
            (identical(other.port, port) || other.port == port));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isStart, systemProxy,
      const DeepCollectionEquality().hash(_bassDomain), port);

  /// Create a copy of ProxyState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxyStateImplCopyWith<_$ProxyStateImpl> get copyWith =>
      __$$ProxyStateImplCopyWithImpl<_$ProxyStateImpl>(this, _$identity);
}

abstract class _ProxyState implements ProxyState {
  const factory _ProxyState(
      {required final bool isStart,
      required final bool systemProxy,
      required final List<String> bassDomain,
      required final int port}) = _$ProxyStateImpl;

  @override
  bool get isStart;
  @override
  bool get systemProxy;
  @override
  List<String> get bassDomain;
  @override
  int get port;

  /// Create a copy of ProxyState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProxyStateImplCopyWith<_$ProxyStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ClashConfigState {
  bool get overrideDns => throw _privateConstructorUsedError;
  ClashConfig get clashConfig => throw _privateConstructorUsedError;
  OverrideData get overrideData => throw _privateConstructorUsedError;
  RouteMode get routeMode => throw _privateConstructorUsedError;

  /// Create a copy of ClashConfigState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ClashConfigStateCopyWith<ClashConfigState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClashConfigStateCopyWith<$Res> {
  factory $ClashConfigStateCopyWith(
          ClashConfigState value, $Res Function(ClashConfigState) then) =
      _$ClashConfigStateCopyWithImpl<$Res, ClashConfigState>;
  @useResult
  $Res call(
      {bool overrideDns,
      ClashConfig clashConfig,
      OverrideData overrideData,
      RouteMode routeMode});

  $ClashConfigCopyWith<$Res> get clashConfig;
  $OverrideDataCopyWith<$Res> get overrideData;
}

/// @nodoc
class _$ClashConfigStateCopyWithImpl<$Res, $Val extends ClashConfigState>
    implements $ClashConfigStateCopyWith<$Res> {
  _$ClashConfigStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ClashConfigState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? overrideDns = null,
    Object? clashConfig = null,
    Object? overrideData = null,
    Object? routeMode = null,
  }) {
    return _then(_value.copyWith(
      overrideDns: null == overrideDns
          ? _value.overrideDns
          : overrideDns // ignore: cast_nullable_to_non_nullable
              as bool,
      clashConfig: null == clashConfig
          ? _value.clashConfig
          : clashConfig // ignore: cast_nullable_to_non_nullable
              as ClashConfig,
      overrideData: null == overrideData
          ? _value.overrideData
          : overrideData // ignore: cast_nullable_to_non_nullable
              as OverrideData,
      routeMode: null == routeMode
          ? _value.routeMode
          : routeMode // ignore: cast_nullable_to_non_nullable
              as RouteMode,
    ) as $Val);
  }

  /// Create a copy of ClashConfigState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ClashConfigCopyWith<$Res> get clashConfig {
    return $ClashConfigCopyWith<$Res>(_value.clashConfig, (value) {
      return _then(_value.copyWith(clashConfig: value) as $Val);
    });
  }

  /// Create a copy of ClashConfigState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OverrideDataCopyWith<$Res> get overrideData {
    return $OverrideDataCopyWith<$Res>(_value.overrideData, (value) {
      return _then(_value.copyWith(overrideData: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ClashConfigStateImplCopyWith<$Res>
    implements $ClashConfigStateCopyWith<$Res> {
  factory _$$ClashConfigStateImplCopyWith(_$ClashConfigStateImpl value,
          $Res Function(_$ClashConfigStateImpl) then) =
      __$$ClashConfigStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool overrideDns,
      ClashConfig clashConfig,
      OverrideData overrideData,
      RouteMode routeMode});

  @override
  $ClashConfigCopyWith<$Res> get clashConfig;
  @override
  $OverrideDataCopyWith<$Res> get overrideData;
}

/// @nodoc
class __$$ClashConfigStateImplCopyWithImpl<$Res>
    extends _$ClashConfigStateCopyWithImpl<$Res, _$ClashConfigStateImpl>
    implements _$$ClashConfigStateImplCopyWith<$Res> {
  __$$ClashConfigStateImplCopyWithImpl(_$ClashConfigStateImpl _value,
      $Res Function(_$ClashConfigStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ClashConfigState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? overrideDns = null,
    Object? clashConfig = null,
    Object? overrideData = null,
    Object? routeMode = null,
  }) {
    return _then(_$ClashConfigStateImpl(
      overrideDns: null == overrideDns
          ? _value.overrideDns
          : overrideDns // ignore: cast_nullable_to_non_nullable
              as bool,
      clashConfig: null == clashConfig
          ? _value.clashConfig
          : clashConfig // ignore: cast_nullable_to_non_nullable
              as ClashConfig,
      overrideData: null == overrideData
          ? _value.overrideData
          : overrideData // ignore: cast_nullable_to_non_nullable
              as OverrideData,
      routeMode: null == routeMode
          ? _value.routeMode
          : routeMode // ignore: cast_nullable_to_non_nullable
              as RouteMode,
    ));
  }
}

/// @nodoc

class _$ClashConfigStateImpl implements _ClashConfigState {
  const _$ClashConfigStateImpl(
      {required this.overrideDns,
      required this.clashConfig,
      required this.overrideData,
      required this.routeMode});

  @override
  final bool overrideDns;
  @override
  final ClashConfig clashConfig;
  @override
  final OverrideData overrideData;
  @override
  final RouteMode routeMode;

  @override
  String toString() {
    return 'ClashConfigState(overrideDns: $overrideDns, clashConfig: $clashConfig, overrideData: $overrideData, routeMode: $routeMode)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClashConfigStateImpl &&
            (identical(other.overrideDns, overrideDns) ||
                other.overrideDns == overrideDns) &&
            (identical(other.clashConfig, clashConfig) ||
                other.clashConfig == clashConfig) &&
            (identical(other.overrideData, overrideData) ||
                other.overrideData == overrideData) &&
            (identical(other.routeMode, routeMode) ||
                other.routeMode == routeMode));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, overrideDns, clashConfig, overrideData, routeMode);

  /// Create a copy of ClashConfigState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ClashConfigStateImplCopyWith<_$ClashConfigStateImpl> get copyWith =>
      __$$ClashConfigStateImplCopyWithImpl<_$ClashConfigStateImpl>(
          this, _$identity);
}

abstract class _ClashConfigState implements ClashConfigState {
  const factory _ClashConfigState(
      {required final bool overrideDns,
      required final ClashConfig clashConfig,
      required final OverrideData overrideData,
      required final RouteMode routeMode}) = _$ClashConfigStateImpl;

  @override
  bool get overrideDns;
  @override
  ClashConfig get clashConfig;
  @override
  OverrideData get overrideData;
  @override
  RouteMode get routeMode;

  /// Create a copy of ClashConfigState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ClashConfigStateImplCopyWith<_$ClashConfigStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DashboardState {
  List<DashboardWidget> get dashboardWidgets =>
      throw _privateConstructorUsedError;
  double get viewWidth => throw _privateConstructorUsedError;

  /// Create a copy of DashboardState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DashboardStateCopyWith<DashboardState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DashboardStateCopyWith<$Res> {
  factory $DashboardStateCopyWith(
          DashboardState value, $Res Function(DashboardState) then) =
      _$DashboardStateCopyWithImpl<$Res, DashboardState>;
  @useResult
  $Res call({List<DashboardWidget> dashboardWidgets, double viewWidth});
}

/// @nodoc
class _$DashboardStateCopyWithImpl<$Res, $Val extends DashboardState>
    implements $DashboardStateCopyWith<$Res> {
  _$DashboardStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DashboardState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dashboardWidgets = null,
    Object? viewWidth = null,
  }) {
    return _then(_value.copyWith(
      dashboardWidgets: null == dashboardWidgets
          ? _value.dashboardWidgets
          : dashboardWidgets // ignore: cast_nullable_to_non_nullable
              as List<DashboardWidget>,
      viewWidth: null == viewWidth
          ? _value.viewWidth
          : viewWidth // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DashboardStateImplCopyWith<$Res>
    implements $DashboardStateCopyWith<$Res> {
  factory _$$DashboardStateImplCopyWith(_$DashboardStateImpl value,
          $Res Function(_$DashboardStateImpl) then) =
      __$$DashboardStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<DashboardWidget> dashboardWidgets, double viewWidth});
}

/// @nodoc
class __$$DashboardStateImplCopyWithImpl<$Res>
    extends _$DashboardStateCopyWithImpl<$Res, _$DashboardStateImpl>
    implements _$$DashboardStateImplCopyWith<$Res> {
  __$$DashboardStateImplCopyWithImpl(
      _$DashboardStateImpl _value, $Res Function(_$DashboardStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of DashboardState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dashboardWidgets = null,
    Object? viewWidth = null,
  }) {
    return _then(_$DashboardStateImpl(
      dashboardWidgets: null == dashboardWidgets
          ? _value._dashboardWidgets
          : dashboardWidgets // ignore: cast_nullable_to_non_nullable
              as List<DashboardWidget>,
      viewWidth: null == viewWidth
          ? _value.viewWidth
          : viewWidth // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$DashboardStateImpl implements _DashboardState {
  const _$DashboardStateImpl(
      {required final List<DashboardWidget> dashboardWidgets,
      required this.viewWidth})
      : _dashboardWidgets = dashboardWidgets;

  final List<DashboardWidget> _dashboardWidgets;
  @override
  List<DashboardWidget> get dashboardWidgets {
    if (_dashboardWidgets is EqualUnmodifiableListView)
      return _dashboardWidgets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_dashboardWidgets);
  }

  @override
  final double viewWidth;

  @override
  String toString() {
    return 'DashboardState(dashboardWidgets: $dashboardWidgets, viewWidth: $viewWidth)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DashboardStateImpl &&
            const DeepCollectionEquality()
                .equals(other._dashboardWidgets, _dashboardWidgets) &&
            (identical(other.viewWidth, viewWidth) ||
                other.viewWidth == viewWidth));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_dashboardWidgets), viewWidth);

  /// Create a copy of DashboardState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DashboardStateImplCopyWith<_$DashboardStateImpl> get copyWith =>
      __$$DashboardStateImplCopyWithImpl<_$DashboardStateImpl>(
          this, _$identity);
}

abstract class _DashboardState implements DashboardState {
  const factory _DashboardState(
      {required final List<DashboardWidget> dashboardWidgets,
      required final double viewWidth}) = _$DashboardStateImpl;

  @override
  List<DashboardWidget> get dashboardWidgets;
  @override
  double get viewWidth;

  /// Create a copy of DashboardState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DashboardStateImplCopyWith<_$DashboardStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProxyCardState {
  String get proxyName => throw _privateConstructorUsedError;
  String? get testUrl => throw _privateConstructorUsedError;

  /// Create a copy of ProxyCardState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProxyCardStateCopyWith<ProxyCardState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProxyCardStateCopyWith<$Res> {
  factory $ProxyCardStateCopyWith(
          ProxyCardState value, $Res Function(ProxyCardState) then) =
      _$ProxyCardStateCopyWithImpl<$Res, ProxyCardState>;
  @useResult
  $Res call({String proxyName, String? testUrl});
}

/// @nodoc
class _$ProxyCardStateCopyWithImpl<$Res, $Val extends ProxyCardState>
    implements $ProxyCardStateCopyWith<$Res> {
  _$ProxyCardStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProxyCardState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? proxyName = null,
    Object? testUrl = freezed,
  }) {
    return _then(_value.copyWith(
      proxyName: null == proxyName
          ? _value.proxyName
          : proxyName // ignore: cast_nullable_to_non_nullable
              as String,
      testUrl: freezed == testUrl
          ? _value.testUrl
          : testUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProxyCardStateImplCopyWith<$Res>
    implements $ProxyCardStateCopyWith<$Res> {
  factory _$$ProxyCardStateImplCopyWith(_$ProxyCardStateImpl value,
          $Res Function(_$ProxyCardStateImpl) then) =
      __$$ProxyCardStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String proxyName, String? testUrl});
}

/// @nodoc
class __$$ProxyCardStateImplCopyWithImpl<$Res>
    extends _$ProxyCardStateCopyWithImpl<$Res, _$ProxyCardStateImpl>
    implements _$$ProxyCardStateImplCopyWith<$Res> {
  __$$ProxyCardStateImplCopyWithImpl(
      _$ProxyCardStateImpl _value, $Res Function(_$ProxyCardStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProxyCardState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? proxyName = null,
    Object? testUrl = freezed,
  }) {
    return _then(_$ProxyCardStateImpl(
      proxyName: null == proxyName
          ? _value.proxyName
          : proxyName // ignore: cast_nullable_to_non_nullable
              as String,
      testUrl: freezed == testUrl
          ? _value.testUrl
          : testUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ProxyCardStateImpl implements _ProxyCardState {
  const _$ProxyCardStateImpl({required this.proxyName, this.testUrl});

  @override
  final String proxyName;
  @override
  final String? testUrl;

  @override
  String toString() {
    return 'ProxyCardState(proxyName: $proxyName, testUrl: $testUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProxyCardStateImpl &&
            (identical(other.proxyName, proxyName) ||
                other.proxyName == proxyName) &&
            (identical(other.testUrl, testUrl) || other.testUrl == testUrl));
  }

  @override
  int get hashCode => Object.hash(runtimeType, proxyName, testUrl);

  /// Create a copy of ProxyCardState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProxyCardStateImplCopyWith<_$ProxyCardStateImpl> get copyWith =>
      __$$ProxyCardStateImplCopyWithImpl<_$ProxyCardStateImpl>(
          this, _$identity);
}

abstract class _ProxyCardState implements ProxyCardState {
  const factory _ProxyCardState(
      {required final String proxyName,
      final String? testUrl}) = _$ProxyCardStateImpl;

  @override
  String get proxyName;
  @override
  String? get testUrl;

  /// Create a copy of ProxyCardState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProxyCardStateImplCopyWith<_$ProxyCardStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$VpnState {
  TunStack get stack => throw _privateConstructorUsedError;
  VpnProps get vpnProps => throw _privateConstructorUsedError;

  /// Create a copy of VpnState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $VpnStateCopyWith<VpnState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VpnStateCopyWith<$Res> {
  factory $VpnStateCopyWith(VpnState value, $Res Function(VpnState) then) =
      _$VpnStateCopyWithImpl<$Res, VpnState>;
  @useResult
  $Res call({TunStack stack, VpnProps vpnProps});

  $VpnPropsCopyWith<$Res> get vpnProps;
}

/// @nodoc
class _$VpnStateCopyWithImpl<$Res, $Val extends VpnState>
    implements $VpnStateCopyWith<$Res> {
  _$VpnStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of VpnState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stack = null,
    Object? vpnProps = null,
  }) {
    return _then(_value.copyWith(
      stack: null == stack
          ? _value.stack
          : stack // ignore: cast_nullable_to_non_nullable
              as TunStack,
      vpnProps: null == vpnProps
          ? _value.vpnProps
          : vpnProps // ignore: cast_nullable_to_non_nullable
              as VpnProps,
    ) as $Val);
  }

  /// Create a copy of VpnState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VpnPropsCopyWith<$Res> get vpnProps {
    return $VpnPropsCopyWith<$Res>(_value.vpnProps, (value) {
      return _then(_value.copyWith(vpnProps: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$VpnStateImplCopyWith<$Res>
    implements $VpnStateCopyWith<$Res> {
  factory _$$VpnStateImplCopyWith(
          _$VpnStateImpl value, $Res Function(_$VpnStateImpl) then) =
      __$$VpnStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TunStack stack, VpnProps vpnProps});

  @override
  $VpnPropsCopyWith<$Res> get vpnProps;
}

/// @nodoc
class __$$VpnStateImplCopyWithImpl<$Res>
    extends _$VpnStateCopyWithImpl<$Res, _$VpnStateImpl>
    implements _$$VpnStateImplCopyWith<$Res> {
  __$$VpnStateImplCopyWithImpl(
      _$VpnStateImpl _value, $Res Function(_$VpnStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of VpnState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stack = null,
    Object? vpnProps = null,
  }) {
    return _then(_$VpnStateImpl(
      stack: null == stack
          ? _value.stack
          : stack // ignore: cast_nullable_to_non_nullable
              as TunStack,
      vpnProps: null == vpnProps
          ? _value.vpnProps
          : vpnProps // ignore: cast_nullable_to_non_nullable
              as VpnProps,
    ));
  }
}

/// @nodoc

class _$VpnStateImpl implements _VpnState {
  const _$VpnStateImpl({required this.stack, required this.vpnProps});

  @override
  final TunStack stack;
  @override
  final VpnProps vpnProps;

  @override
  String toString() {
    return 'VpnState(stack: $stack, vpnProps: $vpnProps)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VpnStateImpl &&
            (identical(other.stack, stack) || other.stack == stack) &&
            (identical(other.vpnProps, vpnProps) ||
                other.vpnProps == vpnProps));
  }

  @override
  int get hashCode => Object.hash(runtimeType, stack, vpnProps);

  /// Create a copy of VpnState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$VpnStateImplCopyWith<_$VpnStateImpl> get copyWith =>
      __$$VpnStateImplCopyWithImpl<_$VpnStateImpl>(this, _$identity);
}

abstract class _VpnState implements VpnState {
  const factory _VpnState(
      {required final TunStack stack,
      required final VpnProps vpnProps}) = _$VpnStateImpl;

  @override
  TunStack get stack;
  @override
  VpnProps get vpnProps;

  /// Create a copy of VpnState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$VpnStateImplCopyWith<_$VpnStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProfileOverrideStateModel {
  ClashConfigSnippet? get snippet => throw _privateConstructorUsedError;
  Set<String> get selectedRules => throw _privateConstructorUsedError;
  OverrideData? get overrideData => throw _privateConstructorUsedError;

  /// Create a copy of ProfileOverrideStateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProfileOverrideStateModelCopyWith<ProfileOverrideStateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProfileOverrideStateModelCopyWith<$Res> {
  factory $ProfileOverrideStateModelCopyWith(ProfileOverrideStateModel value,
          $Res Function(ProfileOverrideStateModel) then) =
      _$ProfileOverrideStateModelCopyWithImpl<$Res, ProfileOverrideStateModel>;
  @useResult
  $Res call(
      {ClashConfigSnippet? snippet,
      Set<String> selectedRules,
      OverrideData? overrideData});

  $ClashConfigSnippetCopyWith<$Res>? get snippet;
  $OverrideDataCopyWith<$Res>? get overrideData;
}

/// @nodoc
class _$ProfileOverrideStateModelCopyWithImpl<$Res,
        $Val extends ProfileOverrideStateModel>
    implements $ProfileOverrideStateModelCopyWith<$Res> {
  _$ProfileOverrideStateModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProfileOverrideStateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? snippet = freezed,
    Object? selectedRules = null,
    Object? overrideData = freezed,
  }) {
    return _then(_value.copyWith(
      snippet: freezed == snippet
          ? _value.snippet
          : snippet // ignore: cast_nullable_to_non_nullable
              as ClashConfigSnippet?,
      selectedRules: null == selectedRules
          ? _value.selectedRules
          : selectedRules // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      overrideData: freezed == overrideData
          ? _value.overrideData
          : overrideData // ignore: cast_nullable_to_non_nullable
              as OverrideData?,
    ) as $Val);
  }

  /// Create a copy of ProfileOverrideStateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ClashConfigSnippetCopyWith<$Res>? get snippet {
    if (_value.snippet == null) {
      return null;
    }

    return $ClashConfigSnippetCopyWith<$Res>(_value.snippet!, (value) {
      return _then(_value.copyWith(snippet: value) as $Val);
    });
  }

  /// Create a copy of ProfileOverrideStateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OverrideDataCopyWith<$Res>? get overrideData {
    if (_value.overrideData == null) {
      return null;
    }

    return $OverrideDataCopyWith<$Res>(_value.overrideData!, (value) {
      return _then(_value.copyWith(overrideData: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ProfileOverrideStateModelImplCopyWith<$Res>
    implements $ProfileOverrideStateModelCopyWith<$Res> {
  factory _$$ProfileOverrideStateModelImplCopyWith(
          _$ProfileOverrideStateModelImpl value,
          $Res Function(_$ProfileOverrideStateModelImpl) then) =
      __$$ProfileOverrideStateModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ClashConfigSnippet? snippet,
      Set<String> selectedRules,
      OverrideData? overrideData});

  @override
  $ClashConfigSnippetCopyWith<$Res>? get snippet;
  @override
  $OverrideDataCopyWith<$Res>? get overrideData;
}

/// @nodoc
class __$$ProfileOverrideStateModelImplCopyWithImpl<$Res>
    extends _$ProfileOverrideStateModelCopyWithImpl<$Res,
        _$ProfileOverrideStateModelImpl>
    implements _$$ProfileOverrideStateModelImplCopyWith<$Res> {
  __$$ProfileOverrideStateModelImplCopyWithImpl(
      _$ProfileOverrideStateModelImpl _value,
      $Res Function(_$ProfileOverrideStateModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProfileOverrideStateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? snippet = freezed,
    Object? selectedRules = null,
    Object? overrideData = freezed,
  }) {
    return _then(_$ProfileOverrideStateModelImpl(
      snippet: freezed == snippet
          ? _value.snippet
          : snippet // ignore: cast_nullable_to_non_nullable
              as ClashConfigSnippet?,
      selectedRules: null == selectedRules
          ? _value._selectedRules
          : selectedRules // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      overrideData: freezed == overrideData
          ? _value.overrideData
          : overrideData // ignore: cast_nullable_to_non_nullable
              as OverrideData?,
    ));
  }
}

/// @nodoc

class _$ProfileOverrideStateModelImpl implements _ProfileOverrideStateModel {
  const _$ProfileOverrideStateModelImpl(
      {this.snippet,
      required final Set<String> selectedRules,
      this.overrideData})
      : _selectedRules = selectedRules;

  @override
  final ClashConfigSnippet? snippet;
  final Set<String> _selectedRules;
  @override
  Set<String> get selectedRules {
    if (_selectedRules is EqualUnmodifiableSetView) return _selectedRules;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_selectedRules);
  }

  @override
  final OverrideData? overrideData;

  @override
  String toString() {
    return 'ProfileOverrideStateModel(snippet: $snippet, selectedRules: $selectedRules, overrideData: $overrideData)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProfileOverrideStateModelImpl &&
            (identical(other.snippet, snippet) || other.snippet == snippet) &&
            const DeepCollectionEquality()
                .equals(other._selectedRules, _selectedRules) &&
            (identical(other.overrideData, overrideData) ||
                other.overrideData == overrideData));
  }

  @override
  int get hashCode => Object.hash(runtimeType, snippet,
      const DeepCollectionEquality().hash(_selectedRules), overrideData);

  /// Create a copy of ProfileOverrideStateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProfileOverrideStateModelImplCopyWith<_$ProfileOverrideStateModelImpl>
      get copyWith => __$$ProfileOverrideStateModelImplCopyWithImpl<
          _$ProfileOverrideStateModelImpl>(this, _$identity);
}

abstract class _ProfileOverrideStateModel implements ProfileOverrideStateModel {
  const factory _ProfileOverrideStateModel(
      {final ClashConfigSnippet? snippet,
      required final Set<String> selectedRules,
      final OverrideData? overrideData}) = _$ProfileOverrideStateModelImpl;

  @override
  ClashConfigSnippet? get snippet;
  @override
  Set<String> get selectedRules;
  @override
  OverrideData? get overrideData;

  /// Create a copy of ProfileOverrideStateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProfileOverrideStateModelImplCopyWith<_$ProfileOverrideStateModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}
